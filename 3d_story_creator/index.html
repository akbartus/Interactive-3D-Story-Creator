<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive 3D Story Creator</title>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script src="post-processing.js"></script>
    <script src="transform-controls.js"></script>
    <script src="gaussian-splat-viewer.js"></script>
    <script src="https://unpkg.com/aframe-troika-text/dist/aframe-troika-text.min.js"></script>

    <style>
        .input-row {
            display: flex;
            gap: 10px;
            /* Space between inputs */
            margin-bottom: 10px;
            /* Space between rows */
        }

        .input-row input,
        #positionX,
        #positionY,
        #positionZ,
        #rotationX,
        #rotationY,
        #rotationZ {
            width: 60px;
            /* Adjust width as needed */
            padding: 8px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }


        /* Panels styling */
        .panel {
            position: fixed;
            top: 0;
            left: 0;

            width: 300px;
            height: 90vh;
            background: white;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
            padding: 80px 20px;

            overflow-y: auto;
            z-index: 1000;
            display: none;
            /* Initially hidden */
        }


        .panel input,
        .panel select {
            width: 250px;
            margin: 10px 0;
            padding: 8px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
            display: block;
        }

        .panel button {
            width: 100%;
            padding: 10px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
        }

        .panel button:hover {
            background-color: #0056b3;
        }

        /* Buttons styling */
        #buttons-container {
            position: fixed;
            z-index: 1001;
            background: #f0f0f0;
            /* width: 300px; */
            height: 40px;
            overflow: hidden;
            padding: 10px;
            top: 0px;
        }

        #buttons-container button {
            margin-bottom: 10px;
            padding: 10px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
        }

        #buttons-container button:hover {
            background-color: #0056b3;
        }

        /* A-Frame scene styling */
        a-scene {
            position: fixed;
            top: 0;
            left: 300px;
            width: calc(100% - 300px);
            height: 100vh;
        }

        #deleteButton {
            margin-top: 10px;
            margin-bottom: 40px;
        }

        /* Start Recording button */
        #startButton {
            background-color: #4CAF50;
            margin-top: 10px;
        }

        /* End Recording button */
        #endButton {
            margin-top: 10px;
            background-color: #f44336;
        }

        /* Download Camera Data button */
        #downloadButton {
            margin-top: 10px;
            background-color: #2196F3;
        }

        /* Style for camera animation loader/file input */
        #fileInput {
            padding: 10px;
            margin-top: 20px;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        /* Optional: Add hover effect */
        #fileInput:hover {
            border-color: #888;
        }

        /* Optional: Add focus effect */
        #fileInput:focus {
            outline: none;
            border-color: #2196F3;
            box-shadow: 0 0 5px rgba(33, 150, 243, 0.5);
        }

        #testAnimation {
            display: none;
        }

        .controls-container {
            display: flex;
            justify-content: flex-end;
            /* Align items to the right */
            align-items: center;
            /* Vertically center items */
            gap: 10px;
            /* Space between items */
            padding: 10px;
            /* Optional: Add padding */
            background-color: #f0f0f0;
            /* Optional: Add background color */
            border-radius: 8px;
            /* Optional: Add rounded corners */
            position: relative;
            z-index: 1001;
        }

        .transform-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            /* Space between WASD and transform controls */
        }

        .transform-icon {
            cursor: pointer;
            padding: 8px;
            border-radius: 4px;
            transition: background-color 0.3s ease;
        }

        .transform-icon:hover {
            background-color: #ddd;
            /* Hover effect */
        }

        .transform-icon svg {
            fill: #333;
            /* Icon color */
            width: 24px;
            height: 24px;
        }


        #gltf-loader {
            z-index: 9999;
        }

        #fly,
        #wasd {
            display: none;
        }


        /* custom scrollbar */
        /* width */
        ::-webkit-scrollbar {
            width: 10px;
        }

        /* Track */
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        /* Handle */
        ::-webkit-scrollbar-thumb {
            background: #888;
        }

        /* Handle on hover */
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>

    <script>
        let controlPanel;
        let blinkInterval;
        let tooltipCount = 0;
        let tooltips = []; // Array to store tooltip objects




        AFRAME.registerComponent("tooltip-component", {
            init: function () {
                // Add event listener to the submit button
                document.getElementById("submit-tooltip").addEventListener("click", () => {
                    this.submittooltip();
                });
            },

            submittooltip: function () {
                const tooltipText = document.getElementById("tooltip-input").value;
                const align = document.getElementById("align-input").value;
                const color = document.getElementById("color-input").value;

                const fillOpacity = document.getElementById("fill-opacity-input").value;
                const font = document.getElementById("font-input").value;
                const fontSize = document.getElementById("font-size-input").value;
                const letterSpacing = document.getElementById("letter-spacing-input").value;
                const lineHeight = document.getElementById("line-height-input").value;
                const maxWidth = document.getElementById("max-width-input").value;

                if (tooltipText) {
                    this.createNewtooltip(tooltipText, align, color, fillOpacity, font, fontSize, letterSpacing, lineHeight, maxWidth);
                }
            },

            createNewtooltip: function (tooltipText, align, color, fillOpacity, font, fontSize, letterSpacing, lineHeight, maxWidth) {
                if (!tooltipText) return;
                tooltipCount++;
                const scene = document.querySelector("a-scene");

                // Create and position the text
                const newText = document.createElement("a-troika-text");
                newText.setAttribute("position", "0 1 0");
                newText.setAttribute("id", `${tooltipCount}`);
                newText.setAttribute("rotation", "0 0 0");
                newText.setAttribute("color", color);
                newText.setAttribute("value", tooltipText);
                newText.setAttribute("align", align);

                newText.setAttribute("fill-opacity", fillOpacity);
                newText.setAttribute("font", font);
                newText.setAttribute("font-size", fontSize);
                newText.setAttribute("letter-spacing", letterSpacing);
                newText.setAttribute("line-height", lineHeight);
                newText.setAttribute("max-width", maxWidth);

                scene.appendChild(newText);

                // Interaction handling
                const isTouch = "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
                const STARTEVENT = isTouch ? "touchstart" : "mousedown";
                const ENDEVENT = isTouch ? "touchend" : "mouseup";

                window.setTimeout(() => {
                    new Editor();
                }, 100);
            }
        });




        AFRAME.registerComponent('camera-movement-recorder', {
            init: function () {
                this.dataLog = {};
                this.isRecording = false;
                this.currentStep = 1;
                this.cameraEl = this.el;

                this.startRecording = this.startRecording.bind(this);
                this.endRecording = this.endRecording.bind(this);
                this.downloadData = this.downloadData.bind(this);

                // Add event listeners to the buttons
                document.getElementById('startButton').addEventListener('click', () => {
                    this.startRecording(document.getElementById('startButton'));
                });

                document.getElementById('endButton').addEventListener('click', () => {
                    this.endRecording(document.getElementById('startButton'));
                });

                document.getElementById('downloadButton').addEventListener('click', () => {
                    this.downloadData();
                    document.getElementById("testAnimation").style.display = "block";
                });


            },

            tick: function () {
                if (!this.isRecording) return;

                let position = this.cameraEl.object3D.position;
                let rotation = this.cameraEl.object3D.rotation;

                let currentData = {
                    position: [position.x.toFixed(2), position.y.toFixed(2), position.z.toFixed(2)],
                    rotation: [
                        THREE.MathUtils.radToDeg(rotation.x).toFixed(2),
                        THREE.MathUtils.radToDeg(rotation.y).toFixed(2),
                        THREE.MathUtils.radToDeg(rotation.z).toFixed(2)
                    ]
                };

                this.dataLog[`step_${this.currentStep}`].position.push(currentData.position);
                this.dataLog[`step_${this.currentStep}`].rotation.push(currentData.rotation);
            },

            startRecording: function (startButton) {
                this.isRecording = true;
                this.dataLog[`step_${this.currentStep}`] = { position: [], rotation: [] };

                // Make the Start Recording button blink
                blinkInterval = setInterval(() => {
                    startButton.style.visibility = startButton.style.visibility === 'hidden' ? 'visible' : 'hidden';
                }, 500);

                // Change button text to "Recording"
                startButton.textContent = 'Recording';
            },

            endRecording: function (startButton) {
                if (this.isRecording) {
                    this.isRecording = false;
                    this.currentStep++;

                    // Stop the blinking of the Start Recording button
                    clearInterval(blinkInterval);
                    startButton.style.visibility = 'visible'; // Ensure button is visible after stop

                    // Reset the button text to "Start Recording"
                    startButton.textContent = 'Start Recording';
                }
            },

            downloadData: function () {
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(this.dataLog, null, 2));
                const downloadAnchor = document.createElement('a');
                downloadAnchor.setAttribute('href', dataStr);
                downloadAnchor.setAttribute('download', 'camera_data.json');
                document.body.appendChild(downloadAnchor);
                downloadAnchor.click();
                document.body.removeChild(downloadAnchor);
            }
        });

        AFRAME.registerComponent('camera-movement-animator', {
            schema: { type: 'string' },

            init: function () {
                fileInput = document.querySelector("#fileInput");
                fileInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            this.animationData = JSON.parse(e.target.result);
                            this.steps = Object.keys(this.animationData);
                            this.currentStepIndex = 0;
                            this.currentIndex = 0;
                            this.startAnimation();
                        };
                        reader.readAsText(file);
                    }
                });

                // Slider setup
                const speedSlider = document.getElementById('camera-speed');
                const speedValue = document.getElementById('camera-speed-value');

                if (speedSlider && speedValue) {
                    // Initialize the displayed speed value
                    speedValue.textContent = this.data.speed;

                    // Update speed value display and set the speed in the scroll-animator component
                    speedSlider.addEventListener('input', (event) => {
                        const speed = parseInt(event.target.value, 10);
                        speedValue.textContent = speed;

                        // Update the speed in the scroll-animator component
                        this.el.setAttribute('wasd-controls', 'acceleration', speed);
                    });
                }


            },

            startAnimation: function () {
                if (!this.animationData || this.steps.length === 0) return;
                this.el.removeAttribute('look-controls'); // Disable look-controls during animation
                this.animateStep();
            },

            animateStep: function () {
                if (this.currentStepIndex >= this.steps.length) return;
                let stepKey = this.steps[this.currentStepIndex];
                let stepData = this.animationData[stepKey];

                if (this.currentIndex >= stepData.position.length) {
                    this.currentStepIndex++;
                    this.currentIndex = 0;
                    setTimeout(() => this.animateStep(), 100);
                    return;
                }

                let pos = stepData.position[this.currentIndex];
                let rot = stepData.rotation[this.currentIndex];

                this.el.setAttribute('position', `${pos[0]} ${pos[1]} ${pos[2]}`);

                let quaternion = new THREE.Quaternion();
                quaternion.setFromEuler(new THREE.Euler(
                    THREE.MathUtils.degToRad(rot[0]),
                    THREE.MathUtils.degToRad(rot[1]),
                    THREE.MathUtils.degToRad(rot[2]),
                    'YXZ'
                ));
                this.el.object3D.quaternion.slerp(quaternion, 0.1);

                this.currentIndex++;
                setTimeout(() => this.animateStep(), 100);
            }
        });



        // Function to toggle panels

        function togglePanel(panelId) {
            const translate = document.getElementById('translateIcon');
            const rotate = document.getElementById('rotateIcon');
            const scale = document.getElementById('scaleIcon');
            const wasd = document.getElementById('wasd');
            const fly = document.getElementById('fly');
            const panels = document.querySelectorAll('.panel');

            panels.forEach(panel => {
                panel.style.display = panel.id === panelId ?
                    (panel.style.display === 'block' ? 'none' : 'block') :
                    'none';
            });

            const cameras = document.querySelectorAll('[camera]');

            // Ensure there are at least two cameras before toggling
            if (cameras.length >= 2) {
                let isActive = cameras[1].getAttribute('camera').active === 'true';

                // Toggle camera based on panel type
                if (panelId === "camera-panel") {
                    cameras[1].setAttribute('camera', 'active', 'false');
                    cameras[0].setAttribute('camera', 'active', 'true');

                    translate.style.display = "none";
                    rotate.style.display = "none";
                    scale.style.display = "none";
                    wasd.style.display = "block";
                    fly.style.display = "block";
                }
                else if (panelId === "scroll-panel") {
                    cameras[1].setAttribute('camera', 'active', 'false');
                    cameras[0].setAttribute('camera', 'active', 'true');


                    translate.style.display = "none";
                    rotate.style.display = "none";
                    scale.style.display = "none";
                    wasd.style.display = "block";
                    fly.style.display = "block";
                }
                else if (panelId === "tooltip-panel") {
                    cameras[1].setAttribute('camera', 'active', 'true');
                    cameras[0].setAttribute('camera', 'active', 'false');
                    const isTouch = "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
                    const STARTEVENT = isTouch ? "touchstart" : "mousedown";
                    const ENDEVENT = isTouch ? "touchend" : "mouseup";

                    window.setTimeout(() => {
                        new Editor();
                    }, 100);


                    translate.style.display = "block";
                    rotate.style.display = "block";
                    scale.style.display = "block";
                    wasd.style.display = "none";
                    fly.style.display = "none";
                }
                else if (panelId === "3d-panel") {
                    cameras[1].setAttribute('camera', 'active', 'true');
                    cameras[0].setAttribute('camera', 'active', 'false');
                    const isTouch = "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
                    const STARTEVENT = isTouch ? "touchstart" : "mousedown";
                    const ENDEVENT = isTouch ? "touchend" : "mouseup";

                    window.setTimeout(() => {
                        new Editor();
                    }, 100);


                    translate.style.display = "block";
                    rotate.style.display = "block";
                    scale.style.display = "block";
                    wasd.style.display = "none";
                    fly.style.display = "none";
                }
            }
        }





        AFRAME.registerComponent('scroll-animator', {
            schema: {
                speed: { type: 'number', default: 10 } // Speed control for animation
            },

            init: function () {
                // File input setup
                const fileInput = document.querySelector("#fileInput2");
                fileInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            this.animationData = JSON.parse(e.target.result);
                            this.steps = Object.keys(this.animationData);
                            this.currentStepIndex = 0;
                            this.currentIndex = 0;
                            this.setupScrollListener();
                        };
                        reader.readAsText(file);
                    }
                });

                // Slider setup
                const speedSlider = document.getElementById('speed-slider');
                const speedValue = document.getElementById('speed-value');

                if (speedSlider && speedValue) {
                    // Initialize the displayed speed value
                    speedValue.textContent = this.data.speed;

                    // Update speed value display and set the speed in the scroll-animator component
                    speedSlider.addEventListener('input', (event) => {
                        const speed = parseInt(event.target.value, 10);
                        speedValue.textContent = speed;

                        // Update the speed in the scroll-animator component
                        this.el.setAttribute('scroll-animator', 'speed', speed);
                    });
                }
            },

            setupScrollListener: function () {
                if (!this.animationData || this.steps.length === 0) return;
                this.el.removeAttribute('look-controls'); // Disable look-controls during animation

                window.addEventListener('wheel', (event) => {
                    if (event.deltaY > 0) {
                        this.nextFrame();
                    } else {
                        this.previousFrame();
                    }
                });
            },

            nextFrame: function () {
                // Check if animation data is loaded and steps exist
                if (!this.animationData || this.steps.length === 0) return;

                // Stop if already at the end of the animation
                if (this.currentStepIndex >= this.steps.length - 1 && this.currentIndex >= this.animationData[this.steps[this.currentStepIndex]].position.length - 1) {
                    console.log("Reached the end of the animation.");
                    return;
                }

                let stepKey = this.steps[this.currentStepIndex];
                let stepData = this.animationData[stepKey];

                // Boundary check for stepData
                if (!stepData || !stepData.position) {
                    console.error("Invalid step data or missing position array.");
                    return;
                }

                // Advance by the speed value
                this.currentIndex += this.data.speed;

                // Boundary check for currentIndex
                if (this.currentIndex >= stepData.position.length) {
                    this.currentStepIndex++;
                    this.currentIndex = 0;

                    // Stop if we've reached the end of all steps
                    if (this.currentStepIndex >= this.steps.length) {
                        this.currentStepIndex = this.steps.length - 1;
                        this.currentIndex = stepData.position.length - 1; // Stay at the last frame
                        console.log("Reached the end of the animation.");
                        return;
                    }

                    // Move to the next step
                    stepKey = this.steps[this.currentStepIndex];
                    stepData = this.animationData[stepKey];
                }

                this.updateCameraPosition(stepData);
            },

            previousFrame: function () {
                // Check if animation data is loaded and steps exist
                if (!this.animationData || this.steps.length === 0) return;

                // Stop if already at the beginning of the animation
                if (this.currentStepIndex <= 0 && this.currentIndex <= 0) {
                    console.log("Reached the beginning of the animation.");
                    return;
                }

                let stepKey = this.steps[this.currentStepIndex];
                let stepData = this.animationData[stepKey];

                // Boundary check for stepData
                if (!stepData || !stepData.position) {
                    console.error("Invalid step data or missing position array.");
                    return;
                }

                // Go back by the speed value
                this.currentIndex -= this.data.speed;

                // Boundary check for currentIndex
                if (this.currentIndex < 0) {
                    this.currentStepIndex--;
                    this.currentIndex = 0;

                    // Stop if we've reached the beginning of all steps
                    if (this.currentStepIndex < 0) {
                        this.currentStepIndex = 0;
                        this.currentIndex = 0; // Stay at the first frame
                        console.log("Reached the beginning of the animation.");
                        return;
                    }

                    // Move to the previous step
                    stepKey = this.steps[this.currentStepIndex];
                    stepData = this.animationData[stepKey];
                    this.currentIndex = stepData.position.length - 1;
                }

                this.updateCameraPosition(stepData);
            },

            updateCameraPosition: function (stepData) {
                let pos = stepData.position[this.currentIndex];
                let rot = stepData.rotation[this.currentIndex];

                this.el.setAttribute('position', `${pos[0]} ${pos[1]} ${pos[2]}`);

                let quaternion = new THREE.Quaternion();
                quaternion.setFromEuler(new THREE.Euler(
                    THREE.MathUtils.degToRad(rot[0]),
                    THREE.MathUtils.degToRad(rot[1]),
                    THREE.MathUtils.degToRad(rot[2]),
                    'YXZ'
                ));
                this.el.object3D.quaternion.slerp(quaternion, 0.1);
            }
        });



        document.addEventListener('DOMContentLoaded', function () {
            // Create the model container entity dynamically
            let modelContainer = document.createElement('a-entity');
            modelContainer.setAttribute('id', 'model-container');
            document.querySelector('a-scene').appendChild(modelContainer);

            // Get reference to the file input
            let fileInput = document.getElementById('gltf-loader');


            // Get references to the position and rotation inputs
            const positionX = document.getElementById('positionX');
            const positionY = document.getElementById('positionY');
            const positionZ = document.getElementById('positionZ');

            const rotationX = document.getElementById('rotationX');
            const rotationY = document.getElementById('rotationY');
            const rotationZ = document.getElementById('rotationZ');

            // Function to update position
            function updatePosition() {
                const x = parseFloat(positionX.value) || 0;
                const y = parseFloat(positionY.value) || 0;
                const z = parseFloat(positionZ.value) || 0;

                // Update the position of the last added entity
                const entities = modelContainer.querySelectorAll('a-entity');
                if (entities.length > 0) {
                    const lastEntity = entities[entities.length - 1];
                    lastEntity.setAttribute('position', { x, y, z });
                }
            }

            // Function to update rotation
            function updateRotation() {
                const x = parseFloat(rotationX.value) || 0;
                const y = parseFloat(rotationY.value) || 0;
                const z = parseFloat(rotationZ.value) || 0;

                // Update the rotation of the last added entity
                const entities = modelContainer.querySelectorAll('a-entity');
                if (entities.length > 0) {
                    const lastEntity = entities[entities.length - 1];
                    lastEntity.setAttribute('rotation', { x, y, z });
                }
            }

            // Add event listeners to position inputs
            positionX.addEventListener('input', updatePosition);
            positionY.addEventListener('input', updatePosition);
            positionZ.addEventListener('input', updatePosition);

            // Add event listeners to rotation inputs
            rotationX.addEventListener('input', updateRotation);
            rotationY.addEventListener('input', updateRotation);
            rotationZ.addEventListener('input', updateRotation);
            // Existing file input event listener
            fileInput.addEventListener('change', function (event) {
                const files = event.target.files;

                if (files.length > 0) {
                    Array.from(files).forEach(file => {
                        const url = URL.createObjectURL(file);

                        // Check if the file is a .splat file
                        if (file.name.endsWith('.splat')) {
                            // Create a new Gaussian Splatting entity
                            const splatEntity = document.createElement('a-entity');
                            splatEntity.setAttribute('gaussian-splatting', `src: ${url}`);
                            splatEntity.setAttribute('position', {
                                x: parseFloat(positionX.value) || 0,
                                y: parseFloat(positionY.value) || 0,
                                z: parseFloat(positionZ.value) || 0
                            });
                            splatEntity.setAttribute('rotation', {
                                x: parseFloat(rotationX.value) || 0,
                                y: parseFloat(rotationY.value) || 0,
                                z: parseFloat(rotationZ.value) || 0
                            });

                            // Add the splat entity to the scene
                            modelContainer.appendChild(splatEntity);

                            // Log the URL for debugging
                            console.log('Loading .splat file:', url);
                        } else {
                            // Create a new GLTF model entity
                            const model = document.createElement('a-entity');
                            model.setAttribute('gltf-model', `url(${url})`);
                            model.setAttribute('position', {
                                x: parseFloat(positionX.value) || 0,
                                y: parseFloat(positionY.value) || 0,
                                z: parseFloat(positionZ.value) || 0
                            });
                            model.setAttribute('rotation', {
                                x: parseFloat(rotationX.value) || 0,
                                y: parseFloat(rotationY.value) || 0,
                                z: parseFloat(rotationZ.value) || 0
                            });
                            model.setAttribute('scale', '1 1 1');

                            // Add the model to the scene
                            modelContainer.appendChild(model);
                        }

                        // Interaction handling
                        const isTouch = "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
                        const STARTEVENT = isTouch ? "touchstart" : "mousedown";
                        const ENDEVENT = isTouch ? "touchend" : "mouseup";

                        window.setTimeout(() => {
                            new Editor();
                        }, 100);
                    });
                }
            });

            // Add event listener for WASD mode
            document.querySelector("#wasd").addEventListener("click", () => {
                const entity = document.querySelector('a-entity[wasd-controls]');
                if (entity) {
                    entity.setAttribute("wasd-controls", "fly", false); // Disable fly mode
                }
            });

            // Add event listener for Fly mode
            document.querySelector("#fly").addEventListener("click", () => {
                const entity = document.querySelector('a-entity[wasd-controls]');
                if (entity) {
                    entity.setAttribute("wasd-controls", "fly", true); // Enable fly mode
                }
            });

            document.getElementById('effect-select').addEventListener('change', function () {
                const selectedEffect = this.value;
                const scene = document.querySelector("a-scene");
                scene.setAttribute("post-processing", "effect", selectedEffect);
            });
        });
    </script>
</head>

<body>
    <div class="controls-container">
        <!-- WASD Icon -->
        <div class="transform-controls">
            <div id="wasd" class="transform-icon" title="WASD">
                <?xml version="1.0" encoding="utf-8"?><!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
                <svg fill="#000000" width="800px" height="800px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path
                        d="M20 7h-3V4c0-1.103-.897-2-2-2H9c-1.103 0-2 .897-2 2v3H4c-1.103 0-2 .897-2 2v6c0 1.103.897 2 2 2h3v3c0 1.103.897 2 2 2h6c1.103 0 2-.897 2-2v-3h3c1.103 0 2-.897 2-2V9c0-1.103-.897-2-2-2zm0 8h-5v4h.001v1H9v-5H4V9h5V4h6v5h5v6z" />
                    <path d="M8 14v-4l-3 2zm8 0 3-2-3-2zm-6-6h4l-2-3zm2 11 2-3h-4z" />
                    <circle cx="12" cy="12" r="2" />
                </svg>
            </div>
        </div>

        <!-- Fly Icon -->
        <div id="fly" class="transform-icon" title="Fly">
            <svg width="24px" height="24px" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg">
                <defs></defs>
                <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                    <g id="Icon-Set-Filled" transform="translate(-310.000000, -309.000000)" fill="#000000">
                        <path
                            d="M341.207,309.82 C339.961,308.57 337.771,308.863 336.518,310.119 L330.141,316.481 L318.313,312.061 C317.18,311.768 316.039,311.389 314.634,312.798 C313.917,313.516 312.427,315.01 314.634,317.221 L322.744,323.861 L317.467,329.127 L312.543,327.896 C311.813,327.708 311.321,327.855 310.946,328.269 C310.757,328.505 309.386,329.521 310.342,330.479 L316.067,334.933 L320.521,340.658 C321.213,341.352 321.856,340.919 322.735,340.084 C323.292,339.526 323.172,339.239 323.004,338.426 L321.892,333.536 L327.133,328.277 L333.763,336.389 C335.969,338.6 337.46,337.105 338.177,336.389 C339.583,334.979 339.205,333.837 338.912,332.702 L334.529,320.854 L340.88,314.481 C342.133,313.226 342.454,311.069 341.207,309.82"
                            id="airplane"></path>
                    </g>
                </g>

            </svg>
        </div>

        <!-- Transform Controls -->
        <div class="transform-controls">
            <div id="translateIcon" class="transform-icon" title="Translate">
                <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="up-down-left-right"
                    class="svg-inline--fa fa-up-down-left-right" role="img" xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 512 512">
                    <path fill="currentColor"
                        d="M512 256c0 6.797-2.891 13.28-7.938 17.84l-80 72C419.6 349.9 413.8 352 408 352c-3.312 0-6.625-.6875-9.766-2.078C389.6 346.1 384 337.5 384 328V288h-96v96l40-.0013c9.484 0 18.06 5.578 21.92 14.23s2.25 18.78-4.078 25.83l-72 80C269.3 509.1 262.8 512 255.1 512s-13.28-2.89-17.84-7.937l-71.1-80c-6.328-7.047-7.938-17.17-4.078-25.83s12.44-14.23 21.92-14.23l39.1 .0013V288H128v40c0 9.484-5.578 18.06-14.23 21.92C110.6 351.3 107.3 352 104 352c-5.812 0-11.56-2.109-16.06-6.156l-80-72C2.891 269.3 0 262.8 0 256s2.891-13.28 7.938-17.84l80-72C95 159.8 105.1 158.3 113.8 162.1C122.4 165.9 128 174.5 128 184V224h95.1V128l-39.1-.0013c-9.484 0-18.06-5.578-21.92-14.23S159.8 94.99 166.2 87.94l71.1-80c9.125-10.09 26.56-10.09 35.69 0l72 80c6.328 7.047 7.938 17.17 4.078 25.83s-12.44 14.23-21.92 14.23l-40 .0013V224H384V184c0-9.484 5.578-18.06 14.23-21.92c8.656-3.812 18.77-2.266 25.83 4.078l80 72C509.1 242.7 512 249.2 512 256z">
                    </path>
                </svg>
            </div>
            <div id="rotateIcon" class="transform-icon" title="Rotate">
                <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rotate"
                    class="svg-inline--fa fa-rotate" role="img" xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 512 512">
                    <path fill="currentColor"
                        d="M449.9 39.96l-48.5 48.53C362.5 53.19 311.4 32 256 32C161.5 32 78.59 92.34 49.58 182.2c-5.438 16.81 3.797 34.88 20.61 40.28c16.97 5.5 34.86-3.812 40.3-20.59C130.9 138.5 189.4 96 256 96c37.96 0 73 14.18 100.2 37.8L311.1 178C295.1 194.8 306.8 223.4 330.4 224h146.9C487.7 223.7 496 215.3 496 204.9V59.04C496 34.99 466.9 22.95 449.9 39.96zM441.8 289.6c-16.94-5.438-34.88 3.812-40.3 20.59C381.1 373.5 322.6 416 256 416c-37.96 0-73-14.18-100.2-37.8L200 334C216.9 317.2 205.2 288.6 181.6 288H34.66C24.32 288.3 16 296.7 16 307.1v145.9c0 24.04 29.07 36.08 46.07 19.07l48.5-48.53C149.5 458.8 200.6 480 255.1 480c94.45 0 177.4-60.34 206.4-150.2C467.9 313 458.6 294.1 441.8 289.6z">
                    </path>
                </svg>
            </div>
            <div id="scaleIcon" class="transform-icon" title="Scale">
                <svg aria-hidden="true" focusable="false" data-prefix="fas"
                    data-icon="up-right-and-down-left-from-center"
                    class="svg-inline--fa fa-up-right-and-down-left-from-center" role="img"
                    xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
                    <path fill="currentColor"
                        d="M208 281.4c-12.5-12.5-32.76-12.5-45.26-.002l-78.06 78.07l-30.06-30.06c-6.125-6.125-14.31-9.367-22.63-9.367c-4.125 0-8.279 .7891-12.25 2.43c-11.97 4.953-19.75 16.62-19.75 29.56v135.1C.0013 501.3 10.75 512 24 512h136c12.94 0 24.63-7.797 29.56-19.75c4.969-11.97 2.219-25.72-6.938-34.87l-30.06-30.06l78.06-78.07c12.5-12.49 12.5-32.75 .002-45.25L208 281.4zM487.1 0h-136c-12.94 0-24.63 7.797-29.56 19.75c-4.969 11.97-2.219 25.72 6.938 34.87l30.06 30.06l-78.06 78.07c-12.5 12.5-12.5 32.76 0 45.26l22.62 22.62c12.5 12.5 32.76 12.5 45.26 0l78.06-78.07l30.06 30.06c9.156 9.141 22.87 11.84 34.87 6.937C504.2 184.6 512 172.9 512 159.1V23.1C512 10.74 501.3 0 487.1 0z">
                    </path>
                </svg>
            </div>
        </div>
    </div>


    <!-- Buttons container -->
    <div id="buttons-container">
        <button onclick="togglePanel('3d-panel')">3D Creator</button>
        <button onclick="togglePanel('tooltip-panel')">Tooltip Creator</button>
        <button onclick="togglePanel('camera-panel')">Camera Recorder</button>
        <button onclick="togglePanel('scroll-panel')">Scrollytelling</button>
        <button onclick="togglePanel('export-panel')">Export</button>

    </div>



    <!-- Tooltip panel -->
    <div id="3d-panel" class="panel">
        <h2>Upload 3D File</h2>
        <label>Upload .splat, .gltf or .glb files</label>
        <input type="file" id="gltf-loader" accept=".gltf,.glb,.splat" multiple>

        <!-- Position Input -->
        <label>Position:</label>
        <div class="input-row">
            <input type="number" id="positionX" placeholder="X" value="0" step="0.1">
            <input type="number" id="positionY" placeholder="Y" value="0" step="0.1">
            <input type="number" id="positionZ" placeholder="Z" value="0" step="0.1">
        </div>

        <!-- Rotation Input -->
        <label>Rotation:</label>
        <div class="input-row">
            <input type="number" id="rotationX" placeholder="X" value="0" step="10">
            <input type="number" id="rotationY" placeholder="Y" value="0" step="10">
            <input type="number" id="rotationZ" placeholder="Z" value="0" step="10">
        </div>
    </div>

    <div id="tooltip-panel" class="panel">
        <h2>Tooltip options</h2>
        <label>Tooltip text: </label>
        <input type="text" id="tooltip-input" placeholder="Tooltip text...">
        <label>Align text: </label>
        <select id="align-input">
            <option value="left">Left</option>
            <option value="center">Center</option>
            <option value="right">Right</option>
            <option value="justify">Justify</option>
        </select>
        <label>Font size: </label>
        <input type="number" id="font-size-input" placeholder="Font size..." step="0.1" min="0" max="10">
        <label>Font color: </label>
        <input type="color" id="color-input" placeholder="Font color...">
        <label>Font opacity: </label>
        <input type="number" id="fill-opacity-input" placeholder="Fill opacity..." step="0.1" min="0" max="1">
        <label>Custom font URL: </label>
        <input type="text" id="font-input" placeholder="Custom font URL...">
        <label>Letter spacing: </label>
        <input type="number" id="letter-spacing-input" placeholder="Letter spacing...">
        <label>Line height: </label>
        <input type="number" id="line-height-input" placeholder="Line height...">
        <label>Font max width: </label>
        <input type="number" id="max-width-input" placeholder="Font max width...">

        <br>
        <button id="submit-tooltip">Create</button> <button id="deleteButton">Delete</button>
    </div>

    <!-- Camera panel -->
    <div id="camera-panel" class="panel">
        <h2>Record Camera Animation</h2>
        <label for="speed-slider">Camera Speed:</label>
        <span id="camera-speed-value">10</span>
        <input type="range" id="camera-speed" min="1" max="100" value="10">

        <label for="effect-select">Choose post-processing effect:</label>
        <select id="effect-select">
            <option value="none">None</option>
            <option value="sketchy-pencil">Sketchy Pencil</option>
            <option value="halftone">Halftone</option>
            <option value="old-film">Old Film</option>
            <option value="pixel">Pixel</option>
            <option value="glitch">Glitch</option>
            <option value="sobel">Sobel</option>
            <option value="bloom">Bloom</option>
            <option value="dot-screen">Dot Screen</option>
            <option value="volumetric-light">Volumetric Light</option>
            <option value="afterimage">Afterimage</option>
            <option value="bad-tv">Bad TV</option>
        </select>

        <button id="startButton">Start Recording</button>
        <button id="endButton">End Recording</button>
        <button id="downloadButton">Download Camera Data</button>
        <div id="testAnimation">
            <h2>Test Camera Animation</h2>
            <input type="file" id="fileInput" accept="application/json">
        </div>
    </div>

    <!-- Scroll panel -->
    <div id="scroll-panel" class="panel">
        <h2>Scrollytelling</h2>
        <input type="file" id="fileInput2" accept="application/json">
        <br>
        <label for="speed-slider">Animation Speed:</label>
        <span id="speed-value">10</span>
        <input type="range" id="speed-slider" min="1" max="50" value="10">

    </div>

    <!-- Scroll panel -->
    <div id="export-panel" class="panel">
        <h2>Export</h2>

    </div>

    <!-- A-Frame scene -->
    <a-scene xr-mode-ui="enabled: false" post-processing="effect: none">
        <a-entity camera-movement-recorder camera-movement-animator scroll-animator wasd-controls="acceleration:10"
            look-controls tooltip-component camera position="5.132 1.6 7.237"></a-entity>
        <a-grid position="0 -0.1 0"></a-grid>

    </a-scene>
</body>


</html>