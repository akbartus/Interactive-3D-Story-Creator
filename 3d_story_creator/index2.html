<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title></title>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script src="post-processing.js"></script>
    <script src="transform-controls.js"></script>
    <script src="gaussian-splat-viewer.js"></script>
    <script src="https://unpkg.com/aframe-troika-text/dist/aframe-troika-text.min.js"></script>

    <style>
        .input-row {
            display: flex;
            gap: 10px;
            /* Space between inputs */
            margin-bottom: 10px;
            /* Space between rows */
        }

        .input-row input,
        #positionX,
        #positionY,
        #positionZ,
        #rotationX,
        #rotationY,
        #rotationZ {
            width: 60px;
            /* Adjust width as needed */
            padding: 8px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }


        /* Panels styling */
        .panel {
            position: fixed;
            top: 0;
            left: 0;

            width: 300px;
            height: 90vh;
            background: white;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
            padding: 80px 20px;

            overflow-y: auto;
            z-index: 1000;
            display: none;
            /* Initially hidden */
        }


        .panel input,
        .panel select {
            width: 250px;
            margin: 10px 0;
            padding: 8px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
            display: block;
        }

        .panel button {
            width: 100%;
            padding: 10px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
        }

        .panel button:hover {
            background-color: #0056b3;
        }

        /* Buttons styling */
        #buttons-container {
            position: fixed;
            z-index: 1001;
            background: #f0f0f0;
            /* width: 300px; */
            height: 40px;
            overflow: hidden;
            padding: 10px;
            top: 0px;
        }

        #buttons-container button {
            margin-bottom: 10px;
            padding: 10px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
        }

        #buttons-container button:hover {
            background-color: #0056b3;
        }

        /* A-Frame scene styling */
        a-scene {
            position: fixed;
            top: 0;
            left: 300px;
            width: calc(100% - 300px);
            height: 100vh;
        }

        #deleteButton {
            margin-top: 10px;
            margin-bottom: 40px;
        }

        /* Start Recording button */
        #startButton {
            background-color: #4CAF50;
            margin-top: 10px;
        }

        /* End Recording button */
        #endButton {
            margin-top: 10px;
            background-color: #f44336;
        }

        /* Download Camera Data button */
        #downloadButton {
            margin-top: 10px;
            background-color: #2196F3;
        }

        /* Style for camera animation loader/file input */
        #fileInput {
            padding: 10px;
            margin-top: 20px;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        /* Optional: Add hover effect */
        #fileInput:hover {
            border-color: #888;
        }

        /* Optional: Add focus effect */
        #fileInput:focus {
            outline: none;
            border-color: #2196F3;
            box-shadow: 0 0 5px rgba(33, 150, 243, 0.5);
        }

        #testAnimation {
            display: none;
        }

        .controls-container {
            display: flex;
            justify-content: flex-end;
            /* Align items to the right */
            align-items: center;
            /* Vertically center items */
            gap: 10px;
            /* Space between items */
            padding: 10px;
            /* Optional: Add padding */
            background-color: #f0f0f0;
            /* Optional: Add background color */
            border-radius: 8px;
            /* Optional: Add rounded corners */
            position: relative;
            z-index: 1001;
        }

        .transform-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            /* Space between WASD and transform controls */
        }

        .transform-icon {
            cursor: pointer;
            padding: 8px;
            border-radius: 4px;
            transition: background-color 0.3s ease;
        }

        .transform-icon:hover {
            background-color: #ddd;
            /* Hover effect */
        }

        .transform-icon svg {
            fill: #333;
            /* Icon color */
            width: 24px;
            height: 24px;
        }


        #gltf-loader {
            z-index: 9999;
        }

        #fly,
        #wasd {
            display: none;
        }


        /* custom scrollbar */
        /* width */
        ::-webkit-scrollbar {
            width: 10px;
        }

        /* Track */
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        /* Handle */
        ::-webkit-scrollbar-thumb {
            background: #888;
        }

        /* Handle on hover */
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }


        .text-overlay {
            position: fixed;
            bottom: -100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            transition: bottom 0.5s ease, opacity 0.5s ease;
            opacity: 0;
            z-index: 10000;
        }

        .text-overlay.visible {
            bottom: 50%;
            opacity: 1;
        }

        .text-overlay.hidden {
            bottom: -100px;
            opacity: 0;
        }
    </style>

    <script>
        let controlPanel;
        let blinkInterval;
        let tooltipCount = 0;
        let tooltips = []; // Array to store tooltip objects




        AFRAME.registerComponent("tooltip-component", {
            init: function () {
                // Add event listener to the submit button
                document.getElementById("submit-tooltip").addEventListener("click", () => {
                    this.submittooltip();
                });
            },

            submittooltip: function () {
                const tooltipText = document.getElementById("tooltip-input").value;
                const align = document.getElementById("align-input").value;
                const color = document.getElementById("color-input").value;

                const fillOpacity = document.getElementById("fill-opacity-input").value;
                const font = document.getElementById("font-input").value;
                const fontSize = document.getElementById("font-size-input").value;
                const letterSpacing = document.getElementById("letter-spacing-input").value;
                const lineHeight = document.getElementById("line-height-input").value;
                const maxWidth = document.getElementById("max-width-input").value;

                if (tooltipText) {
                    this.createNewtooltip(tooltipText, align, color, fillOpacity, font, fontSize, letterSpacing, lineHeight, maxWidth);
                }
            },

            createNewtooltip: function (tooltipText, align, color, fillOpacity, font, fontSize, letterSpacing, lineHeight, maxWidth) {
                if (!tooltipText) return;
                tooltipCount++;
                const scene = document.querySelector("a-scene");

                // Create and position the text
                const newText = document.createElement("a-troika-text");
                newText.setAttribute("position", "0 1 0");
                newText.setAttribute("id", `${tooltipCount}`);
                newText.setAttribute("rotation", "0 0 0");
                newText.setAttribute("color", color);
                newText.setAttribute("value", tooltipText);
                newText.setAttribute("align", align);

                newText.setAttribute("fill-opacity", fillOpacity);
                newText.setAttribute("font", font);
                newText.setAttribute("font-size", fontSize);
                newText.setAttribute("letter-spacing", letterSpacing);
                newText.setAttribute("line-height", lineHeight);
                newText.setAttribute("max-width", maxWidth);

                scene.appendChild(newText);

                // Interaction handling
                const isTouch = "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
                const STARTEVENT = isTouch ? "touchstart" : "mousedown";
                const ENDEVENT = isTouch ? "touchend" : "mouseup";

                window.setTimeout(() => {
                    new Editor();
                }, 100);
            }
        });




        AFRAME.registerComponent('camera-movement-recorder', {
            init: function () {
                this.dataLog = {};
                this.isRecording = false;
                this.currentStep = 1;
                this.cameraEl = this.el;
                this.startTime = null;
                this.frameCount = 0;
                this.frameRate = 30; // Frame rate for consistent time calculations

                this.startRecording = this.startRecording.bind(this);
                this.endRecording = this.endRecording.bind(this);
                this.downloadData = this.downloadData.bind(this);

                // Add event listeners to the buttons
                document.getElementById('startButton').addEventListener('click', () => {
                    this.startRecording(document.getElementById('startButton'));
                });

                document.getElementById('endButton').addEventListener('click', () => {
                    this.endRecording(document.getElementById('startButton'));
                });

                document.getElementById('downloadButton').addEventListener('click', () => {
                    this.downloadData();
                    document.getElementById("testAnimation").style.display = "block";
                });
            },

            tick: function () {
                if (!this.isRecording) return;

                let position = this.cameraEl.object3D.position;
                let rotation = this.cameraEl.object3D.rotation;

                let currentData = {
                    position: [position.x.toFixed(2), position.y.toFixed(2), position.z.toFixed(2)],
                    rotation: [
                        THREE.MathUtils.radToDeg(rotation.x).toFixed(2),
                        THREE.MathUtils.radToDeg(rotation.y).toFixed(2),
                        THREE.MathUtils.radToDeg(rotation.z).toFixed(2)
                    ]
                };

                this.dataLog[`step_${this.currentStep}`].position.push(currentData.position);
                this.dataLog[`step_${this.currentStep}`].rotation.push(currentData.rotation);
                this.frameCount++;

                // Update current frame during recording
                document.getElementById('currentFrame').textContent = this.frameCount;
            },

            startRecording: function (startButton) {
                this.isRecording = true;
                this.startTime = Date.now();
                this.frameCount = 0;
                this.dataLog[`step_${this.currentStep}`] = { position: [], rotation: [] };

                // Make the Start Recording button blink
                blinkInterval = setInterval(() => {
                    startButton.style.visibility = startButton.style.visibility === 'hidden' ? 'visible' : 'hidden';
                }, 500);

                // Change button text to "Recording"
                startButton.textContent = 'Recording';

                // Reset current frame display
                document.getElementById('currentFrame').textContent = '0';
            },

            endRecording: function (startButton) {
                if (this.isRecording) {
                    this.isRecording = false;
                    const endTime = Date.now();
                    const duration = (endTime - this.startTime) / 1000; // Duration in seconds

                    // Update the HTML elements with frame count and duration
                    document.getElementById('frameCount').textContent = this.frameCount;
                    document.getElementById('duration').textContent = duration.toFixed(2);

                    // Save frame count and duration in the dataLog
                    this.dataLog[`step_${this.currentStep}`].frameCount = this.frameCount;
                    this.dataLog[`step_${this.currentStep}`].duration = duration;
                    this.dataLog[`step_${this.currentStep}`].frameRate = this.frameRate; // Save frame rate

                    this.currentStep++;

                    // Stop the blinking of the Start Recording button
                    clearInterval(blinkInterval);
                    startButton.style.visibility = 'visible'; // Ensure button is visible after stop

                    // Reset the button text to "Start Recording"
                    startButton.textContent = 'Start Recording';
                }
            },

            downloadData: function () {
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(this.dataLog, null, 2));
                const downloadAnchor = document.createElement('a');
                downloadAnchor.setAttribute('href', dataStr);
                downloadAnchor.setAttribute('download', 'camera_data.json');
                document.body.appendChild(downloadAnchor);
                downloadAnchor.click();
                document.body.removeChild(downloadAnchor);
            }
        });





        AFRAME.registerComponent('camera-movement-animator', {
            schema: { type: 'string' },

            init: function () {
                this.animationData = null;
                this.steps = [];
                this.currentStepIndex = 0;
                this.currentIndex = 0;
                this.startTime = null;
                this.frameRate = 30; // Use the same frame rate as during recording

                fileInput = document.querySelector("#fileInput");
                fileInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            this.animationData = JSON.parse(e.target.result);
                            this.steps = Object.keys(this.animationData);
                            this.currentStepIndex = 0;
                            this.currentIndex = 0;

                            // Display total frame count and duration from the loaded JSON
                            const stepKey = this.steps[0]; // Assuming only one step for simplicity
                            const frameCount = this.animationData[stepKey].frameCount;
                            const duration = this.animationData[stepKey].duration;
                            document.getElementById('frameCount').textContent = frameCount;
                            document.getElementById('duration').textContent = duration.toFixed(2);

                            this.startAnimation();
                        };
                        reader.readAsText(file);
                    }
                });

                // Speed slider setup
                const speedSlider = document.getElementById('camera-speed');
                const speedValue = document.getElementById('camera-speed-value');
                const wasdEntity = document.querySelector('a-entity[wasd-controls]');

                if (speedSlider && speedValue && wasdEntity) {
                    // Initialize the displayed speed value
                    speedValue.textContent = speedSlider.value;

                    // Update speed value display and set the acceleration in wasd-controls
                    speedSlider.addEventListener('input', (event) => {
                        const speed = parseFloat(event.target.value);
                        speedValue.textContent = speed;

                        // Update the acceleration in wasd-controls
                        wasdEntity.setAttribute('wasd-controls', 'acceleration', speed);
                    });
                }
            },

            startAnimation: function () {
                if (!this.animationData || this.steps.length === 0) return;
                this.el.removeAttribute('look-controls'); // Disable look-controls during animation
                this.startTime = Date.now(); // Record the start time of the animation
                this.animateStep();
            },

            animateStep: function () {
                if (this.currentStepIndex >= this.steps.length) return;
                let stepKey = this.steps[this.currentStepIndex];
                let stepData = this.animationData[stepKey];

                if (this.currentIndex >= stepData.position.length) {
                    this.currentStepIndex++;
                    this.currentIndex = 0;
                    setTimeout(() => this.animateStep(), 100);
                    return;
                }

                let pos = stepData.position[this.currentIndex];
                let rot = stepData.rotation[this.currentIndex];

                this.el.setAttribute('position', `${pos[0]} ${pos[1]} ${pos[2]}`);

                let quaternion = new THREE.Quaternion();
                quaternion.setFromEuler(new THREE.Euler(
                    THREE.MathUtils.degToRad(rot[0]),
                    THREE.MathUtils.degToRad(rot[1]),
                    THREE.MathUtils.degToRad(rot[2]),
                    'YXZ'
                ));
                this.el.object3D.quaternion.slerp(quaternion, 0.1);

                // Update current frame
                const currentFrame = this.currentIndex + 1; // Frames are 1-indexed
                document.getElementById('currentFrame').textContent = currentFrame;

                this.currentIndex++;
                setTimeout(() => this.animateStep(), 1000 / this.frameRate); // Use frame rate for smooth playback
            }
        });




        AFRAME.registerComponent('scroll-animator', {
            schema: {
                speed: { type: 'number', default: 10 }
            },

            init: function () {
                this.textOverlays = [];
                this.currentTextIndex = 0;
                this.textDisplayRange = 10; // Default number of frames for fade-in and fade-out

                // File input setup
                const fileInput = document.querySelector("#fileInput2");
                fileInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            this.animationData = JSON.parse(e.target.result);
                            this.steps = Object.keys(this.animationData);
                            this.currentStepIndex = 0;
                            this.currentIndex = 0;

                            // Display total frame count and duration from the loaded JSON
                            const stepKey = this.steps[0]; // Assuming only one step for simplicity
                            const frameCount = this.animationData[stepKey].frameCount;
                            const duration = this.animationData[stepKey].duration;

                            // Update the HTML elements
                            document.querySelector('#frameCount2').textContent = frameCount;
                            document.querySelector('#duration2').textContent = duration.toFixed(2);

                            // Update the "This Frame" slider
                            const frameSlider = document.getElementById('frame-slider');
                            const frameSliderValue = document.getElementById('frame-slider-value');
                            if (frameSlider && frameSliderValue) {
                                frameSlider.max = frameCount - 1; // Set max to total frames - 1
                                frameSlider.value = 0;
                                frameSliderValue.textContent = 0;
                            }

                            this.setupScrollListener();
                        };
                        reader.readAsText(file);
                    }
                });

                // Slider setup
                const speedSlider = document.getElementById('speed-slider');
                const speedValue = document.querySelector('.speed-value');

                if (speedSlider && speedValue) {
                    // Initialize the displayed speed value
                    speedValue.textContent = this.data.speed;

                    // Update speed value display and set the speed in the scroll-animator component
                    speedSlider.addEventListener('input', (event) => {
                        const speed = parseInt(event.target.value, 10);
                        speedValue.textContent = speed;

                        // Update the speed in the scroll-animator component
                        this.el.setAttribute('scroll-animator', 'speed', speed);
                    });
                }

                // Add event listener for the "Add Text" button
                document.getElementById('add-text-button').addEventListener('click', () => {
                    this.addTextInput();
                });

                // Add event listener for the "This Frame" slider
                const frameSlider = document.getElementById('frame-slider');
                const frameSliderValue = document.getElementById('frame-slider-value');

                if (frameSlider && frameSliderValue) {
                    frameSlider.addEventListener('input', (event) => {
                        const frame = parseInt(event.target.value, 10);
                        frameSliderValue.textContent = frame;
                        this.jumpToFrame(frame);
                    });
                }
            },

            addTextInput: function () {
                const container = document.querySelector('.text-inputs-container');
                const newTextInput = document.createElement('div');
                newTextInput.className = 'text-input-row';
                newTextInput.innerHTML = `
            <input type="text" class="scrollableText" placeholder="Enter text...">
            <input type="number" class="frameNumber" placeholder="Frame number">
            <input type="number" class="durationFrames" placeholder="Duration in frames" min="1" value="10">
        `;
                container.appendChild(newTextInput);
            },

            setupScrollListener: function () {
                if (!this.animationData || this.steps.length === 0) return;
                this.el.removeAttribute('look-controls'); // Disable look-controls during animation

                window.addEventListener('wheel', (event) => {
                    if (event.deltaY > 0) {
                        this.nextFrame();
                    } else {
                        this.previousFrame();
                    }
                });
            },

            nextFrame: function () {
                // Check if animation data is loaded and steps exist
                if (!this.animationData || this.steps.length === 0) return;

                // Stop if already at the end of the animation
                if (this.currentStepIndex >= this.steps.length - 1 && this.currentIndex >= this.animationData[this.steps[this.currentStepIndex]].position.length - 1) {
                    console.log("Reached the end of the animation.");
                    return;
                }

                let stepKey = this.steps[this.currentStepIndex];
                let stepData = this.animationData[stepKey];

                // Boundary check for stepData
                if (!stepData || !stepData.position) {
                    console.error("Invalid step data or missing position array.");
                    return;
                }

                // Advance by the speed value
                this.currentIndex += this.data.speed;

                // Boundary check for currentIndex
                if (this.currentIndex >= stepData.position.length) {
                    this.currentStepIndex++;
                    this.currentIndex = 0;

                    // Stop if we've reached the end of all steps
                    if (this.currentStepIndex >= this.steps.length) {
                        this.currentStepIndex = this.steps.length - 1;
                        this.currentIndex = stepData.position.length - 1; // Stay at the last frame
                        console.log("Reached the end of the animation.");
                        return;
                    }

                    // Move to the next step
                    stepKey = this.steps[this.currentStepIndex];
                    stepData = this.animationData[stepKey];
                }

                this.updateCameraPosition(stepData);
                this.updateTextOverlay();
            },

            previousFrame: function () {
                // Check if animation data is loaded and steps exist
                if (!this.animationData || this.steps.length === 0) return;

                // Stop if already at the beginning of the animation
                if (this.currentStepIndex <= 0 && this.currentIndex <= 0) {
                    console.log("Reached the beginning of the animation.");
                    return;
                }

                let stepKey = this.steps[this.currentStepIndex];
                let stepData = this.animationData[stepKey];

                // Boundary check for stepData
                if (!stepData || !stepData.position) {
                    console.error("Invalid step data or missing position array.");
                    return;
                }

                // Go back by the speed value
                this.currentIndex -= this.data.speed;

                // Boundary check for currentIndex
                if (this.currentIndex < 0) {
                    this.currentStepIndex--;
                    this.currentIndex = 0;

                    // Stop if we've reached the beginning of all steps
                    if (this.currentStepIndex < 0) {
                        this.currentStepIndex = 0;
                        this.currentIndex = 0; // Stay at the first frame
                        console.log("Reached the beginning of the animation.");
                        return;
                    }

                    // Move to the previous step
                    stepKey = this.steps[this.currentStepIndex];
                    stepData = this.animationData[stepKey];
                    this.currentIndex = stepData.position.length - 1;
                }

                this.updateCameraPosition(stepData);
                this.updateTextOverlay();
            },

            jumpToFrame: function (frame) {
                if (!this.animationData || this.steps.length === 0) return;

                // Calculate the step and index for the given frame
                let stepKey = this.steps[this.currentStepIndex];
                let stepData = this.animationData[stepKey];

                if (frame >= 0 && frame < stepData.position.length) {
                    this.currentIndex = frame;
                    this.updateCameraPosition(stepData);
                    this.updateTextOverlay();
                }
            },

            updateCameraPosition: function (stepData) {
                let pos = stepData.position[this.currentIndex];
                let rot = stepData.rotation[this.currentIndex];

                this.el.setAttribute('position', `${pos[0]} ${pos[1]} ${pos[2]}`);

                let quaternion = new THREE.Quaternion();
                quaternion.setFromEuler(new THREE.Euler(
                    THREE.MathUtils.degToRad(rot[0]),
                    THREE.MathUtils.degToRad(rot[1]),
                    THREE.MathUtils.degToRad(rot[2]),
                    'YXZ'
                ));
                this.el.object3D.quaternion.slerp(quaternion, 0.1);

                // Update current frame
                const currentFrame = this.currentIndex + 1; // Frames are 1-indexed
                document.querySelector('#currentFrame2').textContent = currentFrame;

                // Update the "This Frame" slider
                const frameSlider = document.getElementById('frame-slider');
                const frameSliderValue = document.getElementById('frame-slider-value');
                if (frameSlider && frameSliderValue) {
                    frameSlider.value = this.currentIndex;
                    frameSliderValue.textContent = this.currentIndex;
                }
            },

            updateTextOverlay: function () {
                const currentFrame = this.currentIndex + 1;
                const textInputs = document.querySelectorAll('.text-input-row');
                let foundText = false;

                textInputs.forEach((inputRow, index) => {
                    const frameNumberInput = inputRow.querySelector('.frameNumber');
                    const textInput = inputRow.querySelector('.scrollableText');
                    const durationInput = inputRow.querySelector('.durationFrames');
                    const frameNumber = parseInt(frameNumberInput.value, 10);
                    const durationFrames = parseInt(durationInput.value, 10);

                    // Calculate the range of frames where the text should be visible
                    const startFrame = frameNumber - this.textDisplayRange;
                    const endFrame = frameNumber + durationFrames + this.textDisplayRange;

                    if (currentFrame >= startFrame && currentFrame <= endFrame) {
                        const progress = this.calculateProgress(currentFrame, frameNumber, durationFrames);
                        this.showTextOverlay(textInput.value, progress);
                        foundText = true;
                    }
                });

                if (!foundText) {
                    this.hideTextOverlay();
                }
            },

            calculateProgress: function (currentFrame, targetFrame, durationFrames) {
                const fadeInEnd = targetFrame;
                const fadeOutStart = targetFrame + durationFrames;
                const fadeOutEnd = fadeOutStart + this.textDisplayRange;

                if (currentFrame < targetFrame) {
                    // Fade in phase: move from bottom to center
                    return (currentFrame - (targetFrame - this.textDisplayRange)) / this.textDisplayRange;
                } else if (currentFrame >= targetFrame && currentFrame < fadeOutStart) {
                    // Stay in center phase
                    return 1;
                } else if (currentFrame >= fadeOutStart && currentFrame <= fadeOutEnd) {
                    // Fade out phase: move from center to top
                    return 1 - (currentFrame - fadeOutStart) / this.textDisplayRange;
                } else {
                    // Outside the visible range
                    return 0;
                }
            },

            showTextOverlay: function (text, progress) {
                let textOverlay = document.querySelector('.text-overlay');
                if (!textOverlay) {
                    textOverlay = document.createElement('div');
                    textOverlay.className = 'text-overlay';
                    document.body.appendChild(textOverlay);
                }
                textOverlay.textContent = text;

                // Calculate opacity and position based on progress
                let opacity, bottom;

                if (progress < 0.5) {
                    // Phase 1: Move from bottom to center and fade in
                    opacity = progress * 2; // Fade in from 0 to 1
                    bottom = 100 - (progress * 100); // Move from bottom (100%) to center (50%)
                } else if (progress >= 0.5 && progress <= 1) {
                    // Phase 2: Stay in the center with full opacity
                    opacity = 1; // Fully visible
                    bottom = 50; // Stay in the center
                } else if (progress > 1 && progress <= 1.5) {
                    // Phase 3: Move from center to top and fade out
                    opacity = 1 - ((progress - 1) * 2); // Fade out from 1 to 0
                    bottom = 50 - ((progress - 1) * 100); // Move from center (50%) to top (0%)
                } else {
                    // Phase 4: Completely hidden
                    opacity = 0;
                    bottom = 0;
                }

                textOverlay.style.opacity = opacity;
                textOverlay.style.bottom = `${bottom}%`;
            },

            hideTextOverlay: function () {
                const textOverlay = document.querySelector('.text-overlay');
                if (textOverlay) {
                    textOverlay.style.opacity = 0;
                    textOverlay.style.bottom = '100%'; // Move the text overlay back to the bottom when hiding
                }
            }
        });


        function togglePanel(panelId) {
            const translate = document.getElementById('translateIcon');
            const rotate = document.getElementById('rotateIcon');
            const scale = document.getElementById('scaleIcon');
            const wasd = document.getElementById('wasd');
            const fly = document.getElementById('fly');
            const panels = document.querySelectorAll('.panel');

            panels.forEach(panel => {
                panel.style.display = panel.id === panelId ?
                    (panel.style.display === 'block' ? 'none' : 'block') :
                    'none';
            });

            const cameras = document.querySelectorAll('[camera]');

            // Ensure there are at least two cameras before toggling
            if (cameras.length >= 2) {
                let isActive = cameras[1].getAttribute('camera').active === 'true';

                // Toggle camera based on panel type
                if (panelId === "camera-panel") {
                    cameras[1].setAttribute('camera', 'active', 'false');
                    cameras[0].setAttribute('camera', 'active', 'true');

                    translate.style.display = "none";
                    rotate.style.display = "none";
                    scale.style.display = "none";
                    wasd.style.display = "block";
                    fly.style.display = "block";
                }
                else if (panelId === "scroll-panel") {
                    cameras[1].setAttribute('camera', 'active', 'false');
                    cameras[0].setAttribute('camera', 'active', 'true');


                    translate.style.display = "none";
                    rotate.style.display = "none";
                    scale.style.display = "none";
                    wasd.style.display = "block";
                    fly.style.display = "block";
                }
                else if (panelId === "tooltip-panel") {
                    cameras[1].setAttribute('camera', 'active', 'true');
                    cameras[0].setAttribute('camera', 'active', 'false');
                    const isTouch = "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
                    const STARTEVENT = isTouch ? "touchstart" : "mousedown";
                    const ENDEVENT = isTouch ? "touchend" : "mouseup";

                    window.setTimeout(() => {
                        new Editor();
                    }, 100);


                    translate.style.display = "block";
                    rotate.style.display = "block";
                    scale.style.display = "block";
                    wasd.style.display = "none";
                    fly.style.display = "none";
                }
                else if (panelId === "3d-panel") {
                    cameras[1].setAttribute('camera', 'active', 'true');
                    cameras[0].setAttribute('camera', 'active', 'false');
                    const isTouch = "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
                    const STARTEVENT = isTouch ? "touchstart" : "mousedown";
                    const ENDEVENT = isTouch ? "touchend" : "mouseup";

                    window.setTimeout(() => {
                        new Editor();
                    }, 100);


                    translate.style.display = "block";
                    rotate.style.display = "block";
                    scale.style.display = "block";
                    wasd.style.display = "none";
                    fly.style.display = "none";
                }
            }
        }




        document.addEventListener('DOMContentLoaded', function () {
            // Create the model container entity dynamically
            let modelContainer = document.createElement('a-entity');
            modelContainer.setAttribute('id', 'model-container');
            document.querySelector('a-scene').appendChild(modelContainer);

            // Get reference to the file input
            let fileInput = document.getElementById('gltf-loader');


            // Get references to the position and rotation inputs
            const positionX = document.getElementById('positionX');
            const positionY = document.getElementById('positionY');
            const positionZ = document.getElementById('positionZ');

            const rotationX = document.getElementById('rotationX');
            const rotationY = document.getElementById('rotationY');
            const rotationZ = document.getElementById('rotationZ');

            // Function to update position
            function updatePosition() {
                const x = parseFloat(positionX.value) || 0;
                const y = parseFloat(positionY.value) || 0;
                const z = parseFloat(positionZ.value) || 0;

                // Update the position of the last added entity
                const entities = modelContainer.querySelectorAll('a-entity');
                if (entities.length > 0) {
                    const lastEntity = entities[entities.length - 1];
                    lastEntity.setAttribute('position', { x, y, z });
                }
            }

            // Function to update rotation
            function updateRotation() {
                const x = parseFloat(rotationX.value) || 0;
                const y = parseFloat(rotationY.value) || 0;
                const z = parseFloat(rotationZ.value) || 0;

                // Update the rotation of the last added entity
                const entities = modelContainer.querySelectorAll('a-entity');
                if (entities.length > 0) {
                    const lastEntity = entities[entities.length - 1];
                    lastEntity.setAttribute('rotation', { x, y, z });
                }
            }

            // Add event listeners to position inputs
            positionX.addEventListener('input', updatePosition);
            positionY.addEventListener('input', updatePosition);
            positionZ.addEventListener('input', updatePosition);

            // Add event listeners to rotation inputs
            rotationX.addEventListener('input', updateRotation);
            rotationY.addEventListener('input', updateRotation);
            rotationZ.addEventListener('input', updateRotation);
            // Existing file input event listener
            fileInput.addEventListener('change', function (event) {
                const files = event.target.files;

                if (files.length > 0) {
                    Array.from(files).forEach(file => {
                        const url = URL.createObjectURL(file);

                        // Check if the file is a .splat file
                        if (file.name.endsWith('.splat')) {
                            // Create a new Gaussian Splatting entity
                            const splatEntity = document.createElement('a-entity');
                            splatEntity.setAttribute('gaussian-splatting', `src: ${url}`);
                            splatEntity.setAttribute('position', {
                                x: parseFloat(positionX.value) || 0,
                                y: parseFloat(positionY.value) || 0,
                                z: parseFloat(positionZ.value) || 0
                            });
                            splatEntity.setAttribute('rotation', {
                                x: parseFloat(rotationX.value) || 0,
                                y: parseFloat(rotationY.value) || 0,
                                z: parseFloat(rotationZ.value) || 0
                            });

                            // Add the splat entity to the scene
                            modelContainer.appendChild(splatEntity);

                            // Log the URL for debugging
                            console.log('Loading .splat file:', url);
                        } else {
                            // Create a new GLTF model entity
                            const model = document.createElement('a-entity');
                            model.setAttribute('gltf-model', `url(${url})`);
                            model.setAttribute('position', {
                                x: parseFloat(positionX.value) || 0,
                                y: parseFloat(positionY.value) || 0,
                                z: parseFloat(positionZ.value) || 0
                            });
                            model.setAttribute('rotation', {
                                x: parseFloat(rotationX.value) || 0,
                                y: parseFloat(rotationY.value) || 0,
                                z: parseFloat(rotationZ.value) || 0
                            });
                            model.setAttribute('scale', '1 1 1');

                            // Add the model to the scene
                            modelContainer.appendChild(model);
                        }

                        // Interaction handling
                        const isTouch = "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
                        const STARTEVENT = isTouch ? "touchstart" : "mousedown";
                        const ENDEVENT = isTouch ? "touchend" : "mouseup";

                        window.setTimeout(() => {
                            new Editor();
                        }, 100);
                    });
                }
            });

            // Add event listener for WASD mode
            document.querySelector("#wasd").addEventListener("click", () => {
                const entity = document.querySelector('a-entity[wasd-controls]');
                if (entity) {
                    entity.setAttribute("wasd-controls", "fly", false); // Disable fly mode
                }
            });

            // Add event listener for Fly mode
            document.querySelector("#fly").addEventListener("click", () => {
                const entity = document.querySelector('a-entity[wasd-controls]');
                if (entity) {
                    entity.setAttribute("wasd-controls", "fly", true); // Enable fly mode
                }
            });

            document.getElementById('effect-select').addEventListener('change', function () {
                const selectedEffect = this.value;
                const scene = document.querySelector("a-scene");
                scene.setAttribute("post-processing", "effect", selectedEffect);
            });


            const speedSlider = document.getElementById('camera-speed');
            const speedValue = document.getElementById('camera-speed-value');

            // Get the entity with wasd-controls
            const wasdEntity = document.querySelector('a-entity[wasd-controls]');

            if (speedSlider && speedValue && wasdEntity) {
                // Initialize the displayed speed value
                speedValue.textContent = speedSlider.value;

                // Update speed value display and set the acceleration in wasd-controls
                speedSlider.addEventListener('input', (event) => {
                    const speed = parseFloat(event.target.value);
                    speedValue.textContent = speed;

                    // Update the acceleration in wasd-controls
                    wasdEntity.setAttribute('wasd-controls', 'acceleration', speed);
                });
            }

        });
    </script>
</head>

<body>
    <div class="controls-container">
        <!-- WASD Icon -->
        <div class="transform-controls">
            <div id="wasd" class="transform-icon" title="WASD">
                <?xml version="1.0" encoding="utf-8"?>
                <svg fill="#000000" width="800px" height="800px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path
                        d="M20 7h-3V4c0-1.103-.897-2-2-2H9c-1.103 0-2 .897-2 2v3H4c-1.103 0-2 .897-2 2v6c0 1.103.897 2 2 2h3v3c0 1.103.897 2 2 2h6c1.103 0 2-.897 2-2v-3h3c1.103 0 2-.897 2-2V9c0-1.103-.897-2-2-2zm0 8h-5v4h.001v1H9v-5H4V9h5V4h6v5h5v6z" />
                    <path d="M8 14v-4l-3 2zm8 0 3-2-3-2zm-6-6h4l-2-3zm2 11 2-3h-4z" />
                    <circle cx="12" cy="12" r="2" />
                </svg>
            </div>
        </div>

        <!-- Fly Icon -->
        <div id="fly" class="transform-icon" title="Fly">
            <svg width="24px" height="24px" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg">
                <defs></defs>
                <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                    <g id="Icon-Set-Filled" transform="translate(-310.000000, -309.000000)" fill="#000000">
                        <path
                            d="M341.207,309.82 C339.961,308.57 337.771,308.863 336.518,310.119 L330.141,316.481 L318.313,312.061 C317.18,311.768 316.039,311.389 314.634,312.798 C313.917,313.516 312.427,315.01 314.634,317.221 L322.744,323.861 L317.467,329.127 L312.543,327.896 C311.813,327.708 311.321,327.855 310.946,328.269 C310.757,328.505 309.386,329.521 310.342,330.479 L316.067,334.933 L320.521,340.658 C321.213,341.352 321.856,340.919 322.735,340.084 C323.292,339.526 323.172,339.239 323.004,338.426 L321.892,333.536 L327.133,328.277 L333.763,336.389 C335.969,338.6 337.46,337.105 338.177,336.389 C339.583,334.979 339.205,333.837 338.912,332.702 L334.529,320.854 L340.88,314.481 C342.133,313.226 342.454,311.069 341.207,309.82"
                            id="airplane"></path>
                    </g>
                </g>

            </svg>
        </div>

        <!-- Transform Controls -->
        <div class="transform-controls">
            <div id="translateIcon" class="transform-icon" title="Translate">
                <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="up-down-left-right"
                    class="svg-inline--fa fa-up-down-left-right" role="img" xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 512 512">
                    <path fill="currentColor"
                        d="M512 256c0 6.797-2.891 13.28-7.938 17.84l-80 72C419.6 349.9 413.8 352 408 352c-3.312 0-6.625-.6875-9.766-2.078C389.6 346.1 384 337.5 384 328V288h-96v96l40-.0013c9.484 0 18.06 5.578 21.92 14.23s2.25 18.78-4.078 25.83l-72 80C269.3 509.1 262.8 512 255.1 512s-13.28-2.89-17.84-7.937l-71.1-80c-6.328-7.047-7.938-17.17-4.078-25.83s12.44-14.23 21.92-14.23l39.1 .0013V288H128v40c0 9.484-5.578 18.06-14.23 21.92C110.6 351.3 107.3 352 104 352c-5.812 0-11.56-2.109-16.06-6.156l-80-72C2.891 269.3 0 262.8 0 256s2.891-13.28 7.938-17.84l80-72C95 159.8 105.1 158.3 113.8 162.1C122.4 165.9 128 174.5 128 184V224h95.1V128l-39.1-.0013c-9.484 0-18.06-5.578-21.92-14.23S159.8 94.99 166.2 87.94l71.1-80c9.125-10.09 26.56-10.09 35.69 0l72 80c6.328 7.047 7.938 17.17 4.078 25.83s-12.44 14.23-21.92 14.23l-40 .0013V224H384V184c0-9.484 5.578-18.06 14.23-21.92c8.656-3.812 18.77-2.266 25.83 4.078l80 72C509.1 242.7 512 249.2 512 256z">
                    </path>
                </svg>
            </div>
            <div id="rotateIcon" class="transform-icon" title="Rotate">
                <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rotate"
                    class="svg-inline--fa fa-rotate" role="img" xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 512 512">
                    <path fill="currentColor"
                        d="M449.9 39.96l-48.5 48.53C362.5 53.19 311.4 32 256 32C161.5 32 78.59 92.34 49.58 182.2c-5.438 16.81 3.797 34.88 20.61 40.28c16.97 5.5 34.86-3.812 40.3-20.59C130.9 138.5 189.4 96 256 96c37.96 0 73 14.18 100.2 37.8L311.1 178C295.1 194.8 306.8 223.4 330.4 224h146.9C487.7 223.7 496 215.3 496 204.9V59.04C496 34.99 466.9 22.95 449.9 39.96zM441.8 289.6c-16.94-5.438-34.88 3.812-40.3 20.59C381.1 373.5 322.6 416 256 416c-37.96 0-73-14.18-100.2-37.8L200 334C216.9 317.2 205.2 288.6 181.6 288H34.66C24.32 288.3 16 296.7 16 307.1v145.9c0 24.04 29.07 36.08 46.07 19.07l48.5-48.53C149.5 458.8 200.6 480 255.1 480c94.45 0 177.4-60.34 206.4-150.2C467.9 313 458.6 294.1 441.8 289.6z">
                    </path>
                </svg>
            </div>
            <div id="scaleIcon" class="transform-icon" title="Scale">
                <svg aria-hidden="true" focusable="false" data-prefix="fas"
                    data-icon="up-right-and-down-left-from-center"
                    class="svg-inline--fa fa-up-right-and-down-left-from-center" role="img"
                    xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
                    <path fill="currentColor"
                        d="M208 281.4c-12.5-12.5-32.76-12.5-45.26-.002l-78.06 78.07l-30.06-30.06c-6.125-6.125-14.31-9.367-22.63-9.367c-4.125 0-8.279 .7891-12.25 2.43c-11.97 4.953-19.75 16.62-19.75 29.56v135.1C.0013 501.3 10.75 512 24 512h136c12.94 0 24.63-7.797 29.56-19.75c4.969-11.97 2.219-25.72-6.938-34.87l-30.06-30.06l78.06-78.07c12.5-12.49 12.5-32.75 .002-45.25L208 281.4zM487.1 0h-136c-12.94 0-24.63 7.797-29.56 19.75c-4.969 11.97-2.219 25.72 6.938 34.87l30.06 30.06l-78.06 78.07c-12.5 12.5-12.5 32.76 0 45.26l22.62 22.62c12.5 12.5 32.76 12.5 45.26 0l78.06-78.07l30.06 30.06c9.156 9.141 22.87 11.84 34.87 6.937C504.2 184.6 512 172.9 512 159.1V23.1C512 10.74 501.3 0 487.1 0z">
                    </path>
                </svg>
            </div>
        </div>
    </div>


    <!-- Buttons container -->
    <div id="buttons-container">
        <button onclick="togglePanel('3d-panel')">3D Creator</button>
        <button onclick="togglePanel('tooltip-panel')">Tooltip Creator</button>
        <button onclick="togglePanel('camera-panel')">Camera Recorder</button>
        <button onclick="togglePanel('scroll-panel')">Scrollytelling</button>
        <button onclick="togglePanel('export-panel')">Export</button>

    </div>



    <!-- Tooltip panel -->
    <div id="3d-panel" class="panel">
        <h2>Upload 3D File</h2>
        <label>Upload .splat, .gltf or .glb files</label>
        <input type="file" id="gltf-loader" accept=".gltf,.glb,.splat" multiple>

        <!-- Position Input -->
        <label>Position:</label>
        <div class="input-row">
            <input type="number" id="positionX" placeholder="X" value="0" step="0.1">
            <input type="number" id="positionY" placeholder="Y" value="0" step="0.1">
            <input type="number" id="positionZ" placeholder="Z" value="0" step="0.1">
        </div>

        <!-- Rotation Input -->
        <label>Rotation:</label>
        <div class="input-row">
            <input type="number" id="rotationX" placeholder="X" value="0" step="10">
            <input type="number" id="rotationY" placeholder="Y" value="0" step="10">
            <input type="number" id="rotationZ" placeholder="Z" value="0" step="10">
        </div>
    </div>

    <div id="tooltip-panel" class="panel">
        <h2>Tooltip options</h2>
        <label>Tooltip text: </label>
        <input type="text" id="tooltip-input" placeholder="Tooltip text...">
        <label>Align text: </label>
        <select id="align-input">
            <option value="left">Left</option>
            <option value="center">Center</option>
            <option value="right">Right</option>
            <option value="justify">Justify</option>
        </select>
        <label>Font size: </label>
        <input type="number" id="font-size-input" placeholder="Font size..." step="0.1" min="0" max="10">
        <label>Font color: </label>
        <input type="color" id="color-input" placeholder="Font color...">
        <label>Font opacity: </label>
        <input type="number" id="fill-opacity-input" placeholder="Fill opacity..." step="0.1" min="0" max="1">
        <label>Custom font URL: </label>
        <input type="text" id="font-input" placeholder="Custom font URL...">
        <label>Letter spacing: </label>
        <input type="number" id="letter-spacing-input" placeholder="Letter spacing...">
        <label>Line height: </label>
        <input type="number" id="line-height-input" placeholder="Line height...">
        <label>Font max width: </label>
        <input type="number" id="max-width-input" placeholder="Font max width...">

        <br>
        <button id="submit-tooltip">Create</button> <button id="deleteButton">Delete</button>
    </div>

    <!-- Camera panel -->
    <div id="camera-panel" class="panel">
        <h2>Record Camera Animation</h2>
        <label for="camera-speed">Camera Speed:</label>
        <span id="camera-speed-value">10</span>
        <input type="range" id="camera-speed" min="1" max="100" value="10">

        <label for="effect-select">Choose post-processing effect:</label>
        <select id="effect-select">
            <option value="none">None</option>
            <option value="sketchy-pencil">Sketchy Pencil</option>
            <option value="halftone">Halftone</option>
            <option value="old-film">Old Film</option>
            <option value="pixel">Pixel</option>
            <option value="glitch">Glitch</option>
            <option value="sobel">Sobel</option>
            <option value="bloom">Bloom</option>
            <option value="dot-screen">Dot Screen</option>
            <option value="volumetric-light">Volumetric Light</option>
            <option value="afterimage">Afterimage</option>
            <option value="bad-tv">Bad TV</option>
        </select>

        <button id="startButton">Start Recording</button>
        <button id="endButton">End Recording</button>
        <button id="downloadButton">Download Camera Data</button>

        <!-- Display frame count and duration -->
        <div>
            <p>Current Frame: <span id="currentFrame">0</span></p>
            <p>Total Frames: <span id="frameCount">0</span></p>
            <p>Duration: <span id="duration">0.00</span> seconds</p>

        </div>


        <div id="testAnimation">
            <h2>Test Camera Animation</h2>
            <input type="file" id="fileInput" accept="application/json">
        </div>
    </div>

    <!-- Scroll panel -->
    <div id="scroll-panel" class="panel">
        <h2>Scrollytelling</h2>
        <input type="file" id="fileInput2" accept="application/json">
        <br>
        <label for="speed-slider">Animation Speed:</label>
        <span class="speed-value">10</span>
        <input type="range" id="speed-slider" min="1" max="50" value="10">

        <!-- Display current frame, total frames, and duration -->
        <div>
            <p>Current Frame: <span id="currentFrame2">0</span></p>
            <p>Total Frames: <span id="frameCount2">0</span></p>
            <p>Duration: <span id="duration2">0.00</span> seconds</p>
        </div>

        <!-- Add "This Frame" slider -->
        <label for="frame-slider">This Frame:</label>
        <input type="range" id="frame-slider" min="0" max="0" value="0">
        <span id="frame-slider-value">0</span>

        <label>Textual Content</label>
        <div class="text-inputs-container">
            <div class="text-input-row">
                <input type="text" class="scrollableText" placeholder="Enter text...">
                <input type="number" class="frameNumber" placeholder="Frame number">
                <input type="number" class="durationFrames" placeholder="Duration in frames" min="1" value="10">
            </div>
        </div>
        <button id="add-text-button">Add Text</button>
    </div>


    <!-- Scroll panel -->
    <div id="export-panel" class="panel">
        <h2>Export</h2>

    </div>

    <!-- A-Frame scene -->
    <a-scene xr-mode-ui="enabled: false" post-processing="effect: none">
        <a-entity camera-movement-recorder camera-movement-animator scroll-animator wasd-controls="acceleration:10"
            look-controls tooltip-component camera position="5.132 1.6 7.237"></a-entity>
        <a-grid position="0 -0.1 0"></a-grid>

    </a-scene>
</body>


</html>