<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title></title>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script src="post-processing.js"></script>
    <script src="transform-controls.js"></script>
    <script src="gaussian-splat-viewer.js"></script>
    <script src="https://unpkg.com/aframe-troika-text/dist/aframe-troika-text.min.js"></script>

    <style>
        #tooltip-panel>label {
            font-size: 16px;
        }

        .input-row {
            display: flex;
            gap: 10px;
            /* Space between inputs */
            margin-bottom: 10px;
            /* Space between rows */
        }

        .input-row input {
            width: 60px;
            /* Adjust width as needed */
            padding: 8px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }


        /* Panels styling */
        .panel {
            position: fixed;
            top: 0;
            left: 0;

            width: 300px;
            height: 90vh;
            background: white;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
            padding: 80px 20px;

            overflow-y: auto;
            z-index: 1000;
            display: none;
            /* Initially hidden */
        }


        .panel input,
        textarea,
        .panel select {
            width: 250px;
            margin: 10px 0px;
            padding: 8px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
            display: block;
        }

        .panel button {
            width: 100%;
            padding: 10px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
        }

        .panel button:hover {
            background-color: #0056b3;
        }

        /* Buttons styling */
        #buttons-container {
            position: fixed;
            z-index: 1001;
            background: #f0f0f0;
            /* width: 300px; */
            height: 40px;
            overflow: hidden;
            padding: 10px;
            top: 0px;
        }

        #buttons-container button {
            margin-bottom: 10px;
            padding: 10px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
        }

        #buttons-container button:hover {
            background-color: #0056b3;
        }


        .button-container {
            display: flex;
            /* Arrange buttons in a row */
            gap: 10px;
            /* Space between buttons */
            margin: 10px 0;
            /* Add some margin for spacing */
        }

        .button-container button {
            padding: 10px 20px;
            /* Consistent padding for all buttons */
            font-size: 16px;
            /* Adjust font size */
            border: none;
            /* Remove default border */
            border-radius: 5px;
            /* Add rounded corners */
            cursor: pointer;
            /* Add pointer cursor on hover */
            background-color: #007bff;
            /* Default button color */
            color: white;
            /* Text color */
            transition: background-color 0.3s ease;
            /* Smooth hover effect */
            margin: 0;
            /* Reset margins to ensure consistent height */
        }

        .button-container button:hover {
            background-color: #0056b3;
            /* Darker color on hover */
        }

        #deleteButton {
            background-color: #dc3545;
            /* Red color for delete button */
        }

        #deleteButton:hover {
            background-color: #c82333;
            /* Darker red on hover */
        }





        /* A-Frame scene styling */
        a-scene {
            position: fixed;
            top: 0;
            left: 300px;
            width: calc(100% - 300px);
            height: 100vh;
        }



        /* Start Recording button */
        #startButton {
            background-color: #4CAF50;
            margin-top: 10px;
        }


        #startButton:hover {
            background-color: #45a049;
            /* Darker green on hover */
        }

        /* End Recording button */
        #endButton {
            margin-top: 10px;
            background-color: #f44336;
        }

        /* Download Camera Data button */
        #downloadButton {
            margin-top: 10px;
            background-color: #2196F3;
        }

        /* Style for camera animation loader/file input */
        #fileInput {
            padding: 10px;
            margin-top: 20px;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        /* Optional: Add hover effect */
        #fileInput:hover {
            border-color: #888;
        }

        /* Optional: Add focus effect */
        #fileInput:focus {
            outline: none;
            border-color: #2196F3;
            box-shadow: 0 0 5px rgba(33, 150, 243, 0.5);
        }

        #testAnimation {
            display: none;
        }

        .controls-container {
            display: flex;
            justify-content: flex-end;
            /* Align items to the right */
            align-items: center;
            /* Vertically center items */
            gap: 10px;
            /* Space between items */
            padding: 10px;
            /* Optional: Add padding */
            background-color: #f0f0f0;
            /* Optional: Add background color */
            border-radius: 8px;
            /* Optional: Add rounded corners */
            position: relative;
            z-index: 1001;
        }

        .transform-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            /* Space between WASD and transform controls */
        }

        .transform-icon {
            cursor: pointer;
            padding: 8px;
            border-radius: 4px;
            transition: background-color 0.3s ease;
        }

        .transform-icon:hover {
            background-color: #ddd;
            /* Hover effect */
        }

        .transform-icon img {
            fill: #333;
            /* Icon color */
            width: 24px;
            height: 24px;
        }


        #gltf-loader {
            z-index: 9999;
        }

        #fly,
        #wasd {
            display: none;
        }


        /* custom scrollbar */
        /* width */
        ::-webkit-scrollbar {
            width: 10px;
        }

        /* Track */
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        /* Handle */
        ::-webkit-scrollbar-thumb {
            background: #888;
        }

        /* Handle on hover */
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }


        .text-overlay {
            position: fixed;
            bottom: -100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            transition: bottom 0.5s ease, opacity 0.5s ease;
            opacity: 0;
            z-index: 10000;
        }

        .text-overlay.visible {
            bottom: 50%;
            opacity: 1;
        }

        .text-overlay.hidden {
            bottom: -100px;
            opacity: 0;
        }


        /* Text align */
        .align-icons {
            display: flex;
            gap: 10px;
            /* Space between icons */
            margin: 10px 0;
        }

        .align-icon {
            cursor: pointer;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            transition: background-color 0.3s ease;
        }

        .align-icon:hover {
            background-color: #f0f0f0;
            /* Hover effect */
        }

        .align-icon img {
            width: 24px;
            /* Adjust icon size */
            height: 24px;
        }

        /* Font other */

        #font-other {
            display: flex;
            /* Arrange input groups in a row */
            gap: 10px;
            /* Space between input groups */
            margin: 10px 0;
            /* Add some margin for spacing */
        }

        #font-other2 {
            display: flex;
            /* Arrange input groups in a row */
            gap: 10px;
            /* Space between input groups */
            margin: 10px 0;
            /* Add some margin for spacing */
        }

        .input-group {
            display: flex;
            flex-direction: column;
            /* Stack label and input vertically */
            align-items: flex-start;
            /* Align items to the left */
        }

        .input-group label {
            font-size: 16px;
            /* Adjust label font size */
        }

        .input-group input {
            width: 60px;
            /* Adjust input width as needed */
            padding: 8px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
    </style>

    <script>
        let controlPanel;
        let blinkInterval;
        let tooltipCount = 0;
        let tooltips = []; // Array to store tooltip objects




        AFRAME.registerComponent("tooltip-component", {
            init: function () {
                // Add event listener to the submit button
                document.getElementById("submit-tooltip").addEventListener("click", () => {
                    this.submittooltip();
                });
            },

            submittooltip: function () {
                const tooltipText = document.getElementById("tooltip-input").value;
                const align = document.getElementById("align-input").value;
                const color = document.getElementById("color-input").value;

                const fillOpacity = document.getElementById("fill-opacity-input").value;
                const font = document.getElementById("font-input").value;
                const fontSize = document.getElementById("font-size-input").value;
                const letterSpacing = document.getElementById("letter-spacing-input").value;
                const lineHeight = document.getElementById("line-height-input").value;
                const maxWidth = document.getElementById("max-width-input").value;

                if (tooltipText) {
                    this.createNewtooltip(tooltipText, align, color, fillOpacity, font, fontSize, letterSpacing, lineHeight, maxWidth);
                }
            },

            createNewtooltip: function (tooltipText, align, color, fillOpacity, font, fontSize, letterSpacing, lineHeight, maxWidth) {
                if (!tooltipText) return;
                tooltipCount++;
                const scene = document.querySelector("a-scene");

                // Create and position the text
                const newText = document.createElement("a-troika-text");
                newText.setAttribute("position", "0 1 0");
                newText.setAttribute("id", `${tooltipCount}`);
                newText.setAttribute("rotation", "0 0 0");
                newText.setAttribute("color", color);
                newText.setAttribute("value", tooltipText);
                newText.setAttribute("align", align);

                newText.setAttribute("fill-opacity", fillOpacity);
                newText.setAttribute("font", font);
                newText.setAttribute("font-size", fontSize);
                newText.setAttribute("letter-spacing", letterSpacing);
                newText.setAttribute("line-height", lineHeight);
                newText.setAttribute("max-width", maxWidth);

                scene.appendChild(newText);

                // Interaction handling
                const isTouch = "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
                const STARTEVENT = isTouch ? "touchstart" : "mousedown";
                const ENDEVENT = isTouch ? "touchend" : "mouseup";

                window.setTimeout(() => {
                    new Editor();
                }, 100);
            }
        });




        AFRAME.registerComponent('camera-movement-recorder', {
            init: function () {
                this.dataLog = {};
                this.isRecording = false;
                this.currentStep = 1;
                this.cameraEl = this.el;
                this.startTime = null;
                this.frameCount = 0;
                this.frameRate = 30; // Frame rate for consistent time calculations

                this.startRecording = this.startRecording.bind(this);
                this.endRecording = this.endRecording.bind(this);
                this.downloadData = this.downloadData.bind(this);

                // Add event listeners to the buttons
                document.getElementById('startButton').addEventListener('click', () => {
                    this.startRecording(document.getElementById('startButton'));
                });

                document.getElementById('endButton').addEventListener('click', () => {
                    this.endRecording(document.getElementById('startButton'));
                });

                document.getElementById('downloadButton').addEventListener('click', () => {
                    this.downloadData();
                    document.getElementById("testAnimation").style.display = "block";
                });
            },

            tick: function () {
                if (!this.isRecording) return;

                let position = this.cameraEl.object3D.position;
                let rotation = this.cameraEl.object3D.rotation;

                let currentData = {
                    position: [position.x.toFixed(2), position.y.toFixed(2), position.z.toFixed(2)],
                    rotation: [
                        THREE.MathUtils.radToDeg(rotation.x).toFixed(2),
                        THREE.MathUtils.radToDeg(rotation.y).toFixed(2),
                        THREE.MathUtils.radToDeg(rotation.z).toFixed(2)
                    ]
                };

                this.dataLog[`step_${this.currentStep}`].position.push(currentData.position);
                this.dataLog[`step_${this.currentStep}`].rotation.push(currentData.rotation);
                this.frameCount++;

                // Update current frame during recording
                document.getElementById('currentFrame').textContent = this.frameCount;
            },

            startRecording: function (startButton) {
                this.isRecording = true;
                this.startTime = Date.now();
                this.frameCount = 0;
                this.dataLog[`step_${this.currentStep}`] = { position: [], rotation: [] };

                // Make the Start Recording button blink
                blinkInterval = setInterval(() => {
                    startButton.style.visibility = startButton.style.visibility === 'hidden' ? 'visible' : 'hidden';
                }, 500);

                // Change button text to "Recording"
                startButton.textContent = 'Recording';

                // Reset current frame display
                document.getElementById('currentFrame').textContent = '0';
            },

            endRecording: function (startButton) {
                if (this.isRecording) {
                    this.isRecording = false;
                    const endTime = Date.now();
                    const duration = (endTime - this.startTime) / 1000; // Duration in seconds

                    // Update the HTML elements with frame count and duration
                    document.getElementById('frameCount').textContent = this.frameCount;
                    document.getElementById('duration').textContent = duration.toFixed(2);

                    // Save frame count and duration in the dataLog
                    this.dataLog[`step_${this.currentStep}`].frameCount = this.frameCount;
                    this.dataLog[`step_${this.currentStep}`].duration = duration;
                    this.dataLog[`step_${this.currentStep}`].frameRate = this.frameRate; // Save frame rate

                    this.currentStep++;

                    // Stop the blinking of the Start Recording button
                    clearInterval(blinkInterval);
                    startButton.style.visibility = 'visible'; // Ensure button is visible after stop

                    // Reset the button text to "Start Recording"
                    startButton.textContent = 'Start Recording';
                }
            },

            downloadData: function () {
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(this.dataLog, null, 2));
                const downloadAnchor = document.createElement('a');
                downloadAnchor.setAttribute('href', dataStr);
                downloadAnchor.setAttribute('download', 'camera_data.json');
                document.body.appendChild(downloadAnchor);
                downloadAnchor.click();
                document.body.removeChild(downloadAnchor);
            }
        });





        AFRAME.registerComponent('camera-movement-animator', {
            schema: { type: 'string' },

            init: function () {
                this.animationData = null;
                this.steps = [];
                this.currentStepIndex = 0;
                this.currentIndex = 0;
                this.startTime = null;
                this.frameRate = 30; // Use the same frame rate as during recording

                fileInput = document.querySelector("#fileInput");
                fileInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            this.animationData = JSON.parse(e.target.result);
                            this.steps = Object.keys(this.animationData);
                            this.currentStepIndex = 0;
                            this.currentIndex = 0;

                            // Display total frame count and duration from the loaded JSON
                            const stepKey = this.steps[0]; // Assuming only one step for simplicity
                            const frameCount = this.animationData[stepKey].frameCount;
                            const duration = this.animationData[stepKey].duration;
                            document.getElementById('frameCount').textContent = frameCount;
                            document.getElementById('duration').textContent = duration.toFixed(2);

                            this.startAnimation();
                        };
                        reader.readAsText(file);
                    }
                });

                // Speed slider setup
                const speedSlider = document.getElementById('camera-speed');
                const speedValue = document.getElementById('camera-speed-value');
                const wasdEntity = document.querySelector('a-entity[wasd-controls]');

                if (speedSlider && speedValue && wasdEntity) {
                    // Initialize the displayed speed value
                    speedValue.textContent = speedSlider.value;

                    // Update speed value display and set the acceleration in wasd-controls
                    speedSlider.addEventListener('input', (event) => {
                        const speed = parseFloat(event.target.value);
                        speedValue.textContent = speed;

                        // Update the acceleration in wasd-controls
                        wasdEntity.setAttribute('wasd-controls', 'acceleration', speed);
                    });
                }
            },

            startAnimation: function () {
                if (!this.animationData || this.steps.length === 0) return;
                this.el.removeAttribute('look-controls'); // Disable look-controls during animation
                this.startTime = Date.now(); // Record the start time of the animation
                this.animateStep();
            },

            animateStep: function () {
                if (this.currentStepIndex >= this.steps.length) return;
                let stepKey = this.steps[this.currentStepIndex];
                let stepData = this.animationData[stepKey];

                if (this.currentIndex >= stepData.position.length) {
                    this.currentStepIndex++;
                    this.currentIndex = 0;
                    setTimeout(() => this.animateStep(), 100);
                    return;
                }

                let pos = stepData.position[this.currentIndex];
                let rot = stepData.rotation[this.currentIndex];

                this.el.setAttribute('position', `${pos[0]} ${pos[1]} ${pos[2]}`);

                let quaternion = new THREE.Quaternion();
                quaternion.setFromEuler(new THREE.Euler(
                    THREE.MathUtils.degToRad(rot[0]),
                    THREE.MathUtils.degToRad(rot[1]),
                    THREE.MathUtils.degToRad(rot[2]),
                    'YXZ'
                ));
                this.el.object3D.quaternion.slerp(quaternion, 0.1);

                // Update current frame
                const currentFrame = this.currentIndex + 1; // Frames are 1-indexed
                document.getElementById('currentFrame').textContent = currentFrame;

                this.currentIndex++;
                setTimeout(() => this.animateStep(), 1000 / this.frameRate); // Use frame rate for smooth playback
            }
        });




        AFRAME.registerComponent('scroll-animator', {
            schema: {
                speed: { type: 'number', default: 10 }
            },

            init: function () {
                this.textOverlays = [];
                this.currentTextIndex = 0;
                this.textDisplayRange = 10; // Default number of frames for fade-in and fade-out

                // File input setup
                const fileInput = document.querySelector("#fileInput2");
                fileInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            this.animationData = JSON.parse(e.target.result);
                            this.steps = Object.keys(this.animationData);
                            this.currentStepIndex = 0;
                            this.currentIndex = 0;

                            // Display total frame count and duration from the loaded JSON
                            const stepKey = this.steps[0]; // Assuming only one step for simplicity
                            const frameCount = this.animationData[stepKey].frameCount;
                            const duration = this.animationData[stepKey].duration;

                            // Update the HTML elements
                            document.querySelector('#frameCount2').textContent = frameCount;
                            document.querySelector('#duration2').textContent = duration.toFixed(2);

                            // Update the "This Frame" slider
                            const frameSlider = document.getElementById('frame-slider');
                            const frameSliderValue = document.getElementById('frame-slider-value');
                            if (frameSlider && frameSliderValue) {
                                frameSlider.max = frameCount - 1; // Set max to total frames - 1
                                frameSlider.value = 0;
                                frameSliderValue.textContent = 0;
                            }

                            this.setupScrollListener();
                        };
                        reader.readAsText(file);
                    }
                });

                // Slider setup
                const speedSlider = document.getElementById('speed-slider');
                const speedValue = document.querySelector('.speed-value');

                if (speedSlider && speedValue) {
                    // Initialize the displayed speed value
                    speedValue.textContent = this.data.speed;

                    // Update speed value display and set the speed in the scroll-animator component
                    speedSlider.addEventListener('input', (event) => {
                        const speed = parseInt(event.target.value, 10);
                        speedValue.textContent = speed;

                        // Update the speed in the scroll-animator component
                        this.el.setAttribute('scroll-animator', 'speed', speed);
                    });
                }

                // Add event listener for the "Add Text" button
                document.getElementById('add-text-button').addEventListener('click', () => {
                    this.addTextInput();
                });

                // Add event listener for the "This Frame" slider
                const frameSlider = document.getElementById('frame-slider');
                const frameSliderValue = document.getElementById('frame-slider-value');

                if (frameSlider && frameSliderValue) {
                    frameSlider.addEventListener('input', (event) => {
                        const frame = parseInt(event.target.value, 10);
                        frameSliderValue.textContent = frame;
                        this.jumpToFrame(frame);
                    });
                }
            },

            addTextInput: function () {
                const container = document.querySelector('.text-inputs-container');
                const newTextInput = document.createElement('div');
                newTextInput.className = 'text-input-row';
                newTextInput.innerHTML = `
            <input type="text" class="scrollableText" placeholder="Enter text...">
            <input type="number" class="frameNumber" placeholder="Frame number">
            <input type="number" class="durationFrames" placeholder="Duration in frames" min="1" value="10">
        `;
                container.appendChild(newTextInput);
            },

            setupScrollListener: function () {
                if (!this.animationData || this.steps.length === 0) return;
                this.el.removeAttribute('look-controls'); // Disable look-controls during animation

                window.addEventListener('wheel', (event) => {
                    if (event.deltaY > 0) {
                        this.nextFrame();
                    } else {
                        this.previousFrame();
                    }
                });
            },

            nextFrame: function () {
                // Check if animation data is loaded and steps exist
                if (!this.animationData || this.steps.length === 0) return;

                // Stop if already at the end of the animation
                if (this.currentStepIndex >= this.steps.length - 1 && this.currentIndex >= this.animationData[this.steps[this.currentStepIndex]].position.length - 1) {
                    console.log("Reached the end of the animation.");
                    return;
                }

                let stepKey = this.steps[this.currentStepIndex];
                let stepData = this.animationData[stepKey];

                // Boundary check for stepData
                if (!stepData || !stepData.position) {
                    console.error("Invalid step data or missing position array.");
                    return;
                }

                // Advance by the speed value
                this.currentIndex += this.data.speed;

                // Boundary check for currentIndex
                if (this.currentIndex >= stepData.position.length) {
                    this.currentStepIndex++;
                    this.currentIndex = 0;

                    // Stop if we've reached the end of all steps
                    if (this.currentStepIndex >= this.steps.length) {
                        this.currentStepIndex = this.steps.length - 1;
                        this.currentIndex = stepData.position.length - 1; // Stay at the last frame
                        console.log("Reached the end of the animation.");
                        return;
                    }

                    // Move to the next step
                    stepKey = this.steps[this.currentStepIndex];
                    stepData = this.animationData[stepKey];
                }

                this.updateCameraPosition(stepData);
                this.updateTextOverlay();
            },

            previousFrame: function () {
                // Check if animation data is loaded and steps exist
                if (!this.animationData || this.steps.length === 0) return;

                // Stop if already at the beginning of the animation
                if (this.currentStepIndex <= 0 && this.currentIndex <= 0) {
                    console.log("Reached the beginning of the animation.");
                    return;
                }

                let stepKey = this.steps[this.currentStepIndex];
                let stepData = this.animationData[stepKey];

                // Boundary check for stepData
                if (!stepData || !stepData.position) {
                    console.error("Invalid step data or missing position array.");
                    return;
                }

                // Go back by the speed value
                this.currentIndex -= this.data.speed;

                // Boundary check for currentIndex
                if (this.currentIndex < 0) {
                    this.currentStepIndex--;
                    this.currentIndex = 0;

                    // Stop if we've reached the beginning of all steps
                    if (this.currentStepIndex < 0) {
                        this.currentStepIndex = 0;
                        this.currentIndex = 0; // Stay at the first frame
                        console.log("Reached the beginning of the animation.");
                        return;
                    }

                    // Move to the previous step
                    stepKey = this.steps[this.currentStepIndex];
                    stepData = this.animationData[stepKey];
                    this.currentIndex = stepData.position.length - 1;
                }

                this.updateCameraPosition(stepData);
                this.updateTextOverlay();
            },

            jumpToFrame: function (frame) {
                if (!this.animationData || this.steps.length === 0) return;

                // Calculate the step and index for the given frame
                let stepKey = this.steps[this.currentStepIndex];
                let stepData = this.animationData[stepKey];

                if (frame >= 0 && frame < stepData.position.length) {
                    this.currentIndex = frame;
                    this.updateCameraPosition(stepData);
                    this.updateTextOverlay();
                }
            },

            updateCameraPosition: function (stepData) {
                let pos = stepData.position[this.currentIndex];
                let rot = stepData.rotation[this.currentIndex];

                this.el.setAttribute('position', `${pos[0]} ${pos[1]} ${pos[2]}`);

                let quaternion = new THREE.Quaternion();
                quaternion.setFromEuler(new THREE.Euler(
                    THREE.MathUtils.degToRad(rot[0]),
                    THREE.MathUtils.degToRad(rot[1]),
                    THREE.MathUtils.degToRad(rot[2]),
                    'YXZ'
                ));
                this.el.object3D.quaternion.slerp(quaternion, 0.1);

                // Update current frame
                const currentFrame = this.currentIndex + 1; // Frames are 1-indexed
                document.querySelector('#currentFrame2').textContent = currentFrame;

                // Update the "This Frame" slider
                const frameSlider = document.getElementById('frame-slider');
                const frameSliderValue = document.getElementById('frame-slider-value');
                if (frameSlider && frameSliderValue) {
                    frameSlider.value = this.currentIndex;
                    frameSliderValue.textContent = this.currentIndex;
                }
            },

            updateTextOverlay: function () {
                const currentFrame = this.currentIndex + 1;
                const textInputs = document.querySelectorAll('.text-input-row');
                let foundText = false;

                textInputs.forEach((inputRow, index) => {
                    const frameNumberInput = inputRow.querySelector('.frameNumber');
                    const textInput = inputRow.querySelector('.scrollableText');
                    const durationInput = inputRow.querySelector('.durationFrames');
                    const frameNumber = parseInt(frameNumberInput.value, 10);
                    const durationFrames = parseInt(durationInput.value, 10);

                    // Calculate the range of frames where the text should be visible
                    const startFrame = frameNumber - this.textDisplayRange;
                    const endFrame = frameNumber + durationFrames + this.textDisplayRange;

                    if (currentFrame >= startFrame && currentFrame <= endFrame) {
                        const progress = this.calculateProgress(currentFrame, frameNumber, durationFrames);
                        this.showTextOverlay(textInput.value, progress);
                        foundText = true;
                    }
                });

                if (!foundText) {
                    this.hideTextOverlay();
                }
            },

            calculateProgress: function (currentFrame, targetFrame, durationFrames) {
                const fadeInEnd = targetFrame;
                const fadeOutStart = targetFrame + durationFrames;
                const fadeOutEnd = fadeOutStart + this.textDisplayRange;

                if (currentFrame < targetFrame) {
                    // Fade in phase: move from bottom to center
                    return (currentFrame - (targetFrame - this.textDisplayRange)) / this.textDisplayRange;
                } else if (currentFrame >= targetFrame && currentFrame < fadeOutStart) {
                    // Stay in center phase
                    return 1;
                } else if (currentFrame >= fadeOutStart && currentFrame <= fadeOutEnd) {
                    // Fade out phase: move from center to top
                    return 1 - (currentFrame - fadeOutStart) / this.textDisplayRange;
                } else {
                    // Outside the visible range
                    return 0;
                }
            },

            showTextOverlay: function (text, progress) {
                let textOverlay = document.querySelector('.text-overlay');
                if (!textOverlay) {
                    textOverlay = document.createElement('div');
                    textOverlay.className = 'text-overlay';
                    document.body.appendChild(textOverlay);
                }
                textOverlay.textContent = text;

                // Calculate opacity and position based on progress
                let opacity, bottom;

                if (progress < 0.5) {
                    // Phase 1: Move from bottom to center and fade in
                    opacity = progress * 2; // Fade in from 0 to 1
                    bottom = 100 - (progress * 100); // Move from bottom (100%) to center (50%)
                } else if (progress >= 0.5 && progress <= 1) {
                    // Phase 2: Stay in the center with full opacity
                    opacity = 1; // Fully visible
                    bottom = 50; // Stay in the center
                } else if (progress > 1 && progress <= 1.5) {
                    // Phase 3: Move from center to top and fade out
                    opacity = 1 - ((progress - 1) * 2); // Fade out from 1 to 0
                    bottom = 50 - ((progress - 1) * 100); // Move from center (50%) to top (0%)
                } else {
                    // Phase 4: Completely hidden
                    opacity = 0;
                    bottom = 0;
                }

                textOverlay.style.opacity = opacity;
                textOverlay.style.bottom = `${bottom}%`;
            },

            hideTextOverlay: function () {
                const textOverlay = document.querySelector('.text-overlay');
                if (textOverlay) {
                    textOverlay.style.opacity = 0;
                    textOverlay.style.bottom = '100%'; // Move the text overlay back to the bottom when hiding
                }
            }
        });


        function togglePanel(panelId) {
            const translate = document.getElementById('translateIcon');
            const rotate = document.getElementById('rotateIcon');
            const scale = document.getElementById('scaleIcon');
            const wasd = document.getElementById('wasd');
            const fly = document.getElementById('fly');
            const panels = document.querySelectorAll('.panel');

            panels.forEach(panel => {
                panel.style.display = panel.id === panelId ?
                    (panel.style.display === 'block' ? 'none' : 'block') :
                    'none';
            });

            const cameras = document.querySelectorAll('[camera]');

            // Ensure there are at least two cameras before toggling
            if (cameras.length >= 2) {
                let isActive = cameras[1].getAttribute('camera').active === 'true';

                // Toggle camera based on panel type
                if (panelId === "camera-panel") {
                    cameras[1].setAttribute('camera', 'active', 'false');
                    cameras[0].setAttribute('camera', 'active', 'true');

                    translate.style.display = "none";
                    rotate.style.display = "none";
                    scale.style.display = "none";
                    wasd.style.display = "block";
                    fly.style.display = "block";
                }
                else if (panelId === "scroll-panel") {
                    cameras[1].setAttribute('camera', 'active', 'false');
                    cameras[0].setAttribute('camera', 'active', 'true');


                    translate.style.display = "none";
                    rotate.style.display = "none";
                    scale.style.display = "none";
                    wasd.style.display = "block";
                    fly.style.display = "block";
                }
                else if (panelId === "tooltip-panel") {
                    cameras[1].setAttribute('camera', 'active', 'true');
                    cameras[0].setAttribute('camera', 'active', 'false');
                    const isTouch = "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
                    const STARTEVENT = isTouch ? "touchstart" : "mousedown";
                    const ENDEVENT = isTouch ? "touchend" : "mouseup";

                    window.setTimeout(() => {
                        new Editor();
                    }, 100);


                    translate.style.display = "block";
                    rotate.style.display = "block";
                    scale.style.display = "block";
                    wasd.style.display = "none";
                    fly.style.display = "none";
                }
                else if (panelId === "3d-panel") {
                    cameras[1].setAttribute('camera', 'active', 'true');
                    cameras[0].setAttribute('camera', 'active', 'false');
                    const isTouch = "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
                    const STARTEVENT = isTouch ? "touchstart" : "mousedown";
                    const ENDEVENT = isTouch ? "touchend" : "mouseup";

                    window.setTimeout(() => {
                        new Editor();
                    }, 100);


                    translate.style.display = "block";
                    rotate.style.display = "block";
                    scale.style.display = "block";
                    wasd.style.display = "none";
                    fly.style.display = "none";
                }
            }
        }


        let splatEntityId = 0;

        document.addEventListener('DOMContentLoaded', function () {
            // Create the model container entity dynamically

            // Get reference to the file input
            let fileInput = document.getElementById('gltf-loader');











            fileInput.addEventListener('change', function (event) {
                const files = event.target.files;

                if (files.length > 0) {
                    splatEntityId++
                    Array.from(files).forEach(file => {
                        const url = URL.createObjectURL(file);

                        // Check if the file is a .splat file
                        if (file.name.endsWith('.splat')) {
                            // Create a new Gaussian Splatting entity
                            const splatEntity = document.createElement('a-entity');

                            splatEntity.setAttribute('gaussian-splatting', `src: ${url}`);


                            // Add the splat entity to the scene
                            let modelContainer = document.createElement('a-entity');
                            modelContainer.id = `splat${splatEntityId}`;
                            modelContainer.setAttribute('geometry', {
                                primitive: 'box',
                                width: 5,
                                height: 5,
                                depth: 5
                            });
                            modelContainer.setAttribute('material', {
                                color: 'white', // You can set any color you want for the frame
                                wireframe: true, // This makes the box invisible but shows its frame
                                side: THREE.DoubleSide,
                                transparent: true,
                                opacity: 0.1,
                                toneMapped: false,
                                visible: false
                            });
                            document.querySelector('a-scene').appendChild(modelContainer);
                            modelContainer.appendChild(splatEntity);

                            document.addEventListener("objectPositionUpdate", (event) => {
                                const { id, x, y, z } = event.detail;

                                // Find the specific model container by ID
                                const modelContainer = document.getElementById(id);
                                if (modelContainer) {
                                    // Find the actual splat entity inside the model container
                                    const splatEntity = modelContainer.querySelector('[gaussian-splatting]');
                                    if (splatEntity) {
                                        splatEntity.setAttribute('position', { x, y, z });
                                    }
                                }
                            });

                            // Update rotation event
                            document.addEventListener("objectRotationUpdate", (event) => {
                                const { id, x, y, z } = event.detail;

                                // Find the specific model container by ID
                                const modelContainer = document.getElementById(id);
                                if (modelContainer) {
                                    // Find the actual splat entity inside the model container
                                    const splatEntity = modelContainer.querySelector('[gaussian-splatting]');
                                    if (splatEntity) {
                                        splatEntity.setAttribute('rotation', { x, y, z });
                                    }
                                }
                            });


                            // Log the URL for debugging
                            console.log('Loading .splat file:', url);
                        } else {
                            // Create a new GLTF model entity
                            const model = document.createElement('a-entity');
                            model.setAttribute('gltf-model', `url(${url})`);
                            model.setAttribute('position', {
                                x: parseFloat(positionX.value) || 0,
                                y: parseFloat(positionY.value) || 0,
                                z: parseFloat(positionZ.value) || 0
                            });
                            model.setAttribute('rotation', {
                                x: parseFloat(rotationX.value) || 0,
                                y: parseFloat(rotationY.value) || 0,
                                z: parseFloat(rotationZ.value) || 0
                            });
                            model.setAttribute('scale', '1 1 1');

                            // Add the model to the scene
                            modelContainer.appendChild(model);
                        }

                        // Interaction handling
                        const isTouch = "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
                        const STARTEVENT = isTouch ? "touchstart" : "mousedown";
                        const ENDEVENT = isTouch ? "touchend" : "mouseup";

                        window.setTimeout(() => {
                            new Editor();
                        }, 100);
                    });
                }
            });

            // Add event listener for WASD mode
            document.querySelector("#wasd").addEventListener("click", () => {
                const entity = document.querySelector('a-entity[wasd-controls]');
                if (entity) {
                    entity.setAttribute("wasd-controls", "fly", false); // Disable fly mode
                }
            });

            // Add event listener for Fly mode
            document.querySelector("#fly").addEventListener("click", () => {
                const entity = document.querySelector('a-entity[wasd-controls]');
                if (entity) {
                    entity.setAttribute("wasd-controls", "fly", true); // Enable fly mode
                }
            });

            document.getElementById('effect-select').addEventListener('change', function () {
                const selectedEffect = this.value;
                const scene = document.querySelector("a-scene");
                scene.setAttribute("post-processing", "effect", selectedEffect);
            });


            const speedSlider = document.getElementById('camera-speed');
            const speedValue = document.getElementById('camera-speed-value');

            // Get the entity with wasd-controls
            const wasdEntity = document.querySelector('a-entity[wasd-controls]');

            if (speedSlider && speedValue && wasdEntity) {
                // Initialize the displayed speed value
                speedValue.textContent = speedSlider.value;

                // Update speed value display and set the acceleration in wasd-controls
                speedSlider.addEventListener('input', (event) => {
                    const speed = parseFloat(event.target.value);
                    speedValue.textContent = speed;

                    // Update the acceleration in wasd-controls
                    wasdEntity.setAttribute('wasd-controls', 'acceleration', speed);
                });
            }

        });



    </script>
</head>

<body>
    <div class="controls-container">
        <!-- WASD Icon -->
        <div class="transform-controls">
            <div id="wasd" class="transform-icon" title="WASD">
                <img src="icons/wasd.png">
            </div>
        </div>

        <!-- Fly Icon -->
        <div id="fly" class="transform-icon" title="Fly">
            <img src="icons/fly.png">
        </div>

        <!-- Transform Controls -->
        <div class="transform-controls">
            <div id="translateIcon" class="transform-icon" title="Translate">
                <img src="icons/transform.png">
            </div>
            <div id="rotateIcon" class="transform-icon" title="Rotate">
                <img src="icons/rotate.png">
            </div>
            <div id="scaleIcon" class="transform-icon" title="Scale">
                <img src="icons/scale.png">
            </div>
        </div>
    </div>


    <!-- Buttons container -->
    <div id="buttons-container">
        <button onclick="togglePanel('3d-panel')">3D Creator</button>
        <button onclick="togglePanel('tooltip-panel')">Tooltip Creator</button>
        <button onclick="togglePanel('camera-panel')">Camera Recorder</button>
        <button onclick="togglePanel('scroll-panel')">Scrollytelling</button>
        <button onclick="togglePanel('export-panel')">Export</button>

    </div>



    <!-- Tooltip panel -->
    <div id="3d-panel" class="panel">
        <h2>Upload 3D File</h2>
        <label>Upload .splat, .gltf or .glb files</label>
        <input type="file" id="gltf-loader" accept=".gltf,.glb,.splat" multiple>

        <!-- Position Input -->

    </div>

    <div id="tooltip-panel" class="panel">
        <h2>Create Tooltip</h2>
        <label>Tooltip text: </label>
        <textarea id="tooltip-input" placeholder="Tooltip text..." rows="4" cols="50"></textarea>
        <div id="align-input" class="align-icons">
            <div class="align-icon" data-value="left" title="Left Align">
                <img src="icons/left-align.png" alt="Left Align">
            </div>
            <div class="align-icon" data-value="center" title="Center Align">
                <img src="icons/center-align.png" alt="Center Align">
            </div>
            <div class="align-icon" data-value="right" title="Right Align">
                <img src="icons/right-align.png" alt="Right Align">
            </div>
            <div class="align-icon" data-value="justify" title="Justify Align">
                <img src="icons/justify-align.png" alt="Justify Align">
            </div>
            <div class="align-icon">
                <img src="icons/color.png" alt="Color Picker" id="color-picker-icon">
                <input type="color" id="color-input" style="display: none;">
            </div>
        </div>
        <div id="font-other">
            <div class="input-group">
                <label>Size:</label>
                <input type="number" id="font-size-input" placeholder="Size..." step="0.1" min="0" max="10">
            </div>
            <div class="input-group">
                <label>Height:</label>
                <input type="number" id="line-height-input" placeholder="Height...">
            </div>
            <div class="input-group">
                <label>Spacing:</label>
                <input type="number" id="letter-spacing-input" placeholder="Spacing..." step="0.1" min="0" max="10">
            </div>
        </div>
        <div id="font-other2">
            <div class="input-group">
                <label>Opacity:</label>
                <input type="number" id="fill-opacity-input" placeholder="Opacity..." step="0.1" min="0" max="1">
            </div>
            <div class="input-group">
                <label>Max width:</label>
                <input type="number" id="max-width-input" placeholder="Max width..." step="0.1" min="0" max="5">
            </div>
        </div>

        <label>Custom font URL: </label>
        <input type="text" id="font-input" placeholder="Custom font URL...">

        <br>
        <div class="button-container">
            <button id="submit-tooltip">Create</button>
            <button id="deleteButton">Delete</button>
        </div>
    </div>

    <!-- Camera panel -->
    <div id="camera-panel" class="panel">
        <h2>Record Camera Animation</h2>
        <label for="camera-speed">Camera Speed:</label>
        <span id="camera-speed-value">10</span>
        <input type="range" id="camera-speed" min="1" max="100" value="10">

        <label for="effect-select">Choose post-processing effect:</label>
        <select id="effect-select">
            <option value="none">None</option>
            <option value="sketchy-pencil">Sketchy Pencil</option>
            <option value="halftone">Halftone</option>
            <option value="old-film">Old Film</option>
            <option value="pixel">Pixel</option>
            <option value="glitch">Glitch</option>
            <option value="sobel">Sobel</option>
            <option value="bloom">Bloom</option>
            <option value="dot-screen">Dot Screen</option>
            <option value="volumetric-light">Volumetric Light</option>
            <option value="afterimage">Afterimage</option>
            <option value="bad-tv">Bad TV</option>
        </select>

        <button id="startButton">Start Recording</button>
        <button id="endButton">End Recording</button>
        <button id="downloadButton">Download Camera Data</button>

        <!-- Display frame count and duration -->
        <div>
            <p>Current Frame: <span id="currentFrame">0</span></p>
            <p>Total Frames: <span id="frameCount">0</span></p>
            <p>Duration: <span id="duration">0.00</span> seconds</p>

        </div>


        <div id="testAnimation">
            <h2>Test Camera Animation</h2>
            <input type="file" id="fileInput" accept="application/json">
        </div>
    </div>

    <!-- Scroll panel -->
    <div id="scroll-panel" class="panel">
        <h2>Scrollytelling</h2>
        <input type="file" id="fileInput2" accept="application/json">
        <br>
        <label for="speed-slider">Animation Speed:</label>
        <span class="speed-value">10</span>
        <input type="range" id="speed-slider" min="1" max="50" value="10">

        <!-- Display current frame, total frames, and duration -->
        <div>
            <p>Current Frame: <span id="currentFrame2">0</span></p>
            <p>Total Frames: <span id="frameCount2">0</span></p>
            <p>Duration: <span id="duration2">0.00</span> seconds</p>
        </div>

        <!-- Add "This Frame" slider -->
        <label for="frame-slider">This Frame:</label>
        <input type="range" id="frame-slider" min="0" max="0" value="0">
        <span id="frame-slider-value">0</span>

        <label>Textual Content</label>
        <div class="text-inputs-container">
            <div class="text-input-row">
                <input type="text" class="scrollableText" placeholder="Enter text...">
                <input type="number" class="frameNumber" placeholder="Frame number">
                <input type="number" class="durationFrames" placeholder="Duration in frames" min="1" value="10">
            </div>
        </div>
        <button id="add-text-button">Add Text</button>
    </div>


    <!-- Scroll panel -->
    <div id="export-panel" class="panel">
        <h2>Export</h2>

    </div>

    <!-- A-Frame scene -->
    <a-scene xr-mode-ui="enabled: false" post-processing="effect: none">
        <a-entity camera-movement-recorder camera-movement-animator scroll-animator wasd-controls="acceleration:10"
            look-controls tooltip-component camera position="5.132 1.6 7.237"></a-entity>
        <a-grid position="0 -0.1 0"></a-grid>

    </a-scene>
</body>

</html>